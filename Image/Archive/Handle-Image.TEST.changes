!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 15:41' prior: 73273726!handlePreTest	^ Lesson title: 'handle what is is' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachine." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zipAndTestYourImage :"HowDoUseHandle testImage."If this test fails, you can load the code by loading the configurationOfHandle""ProfStef next.'! !ProfStef goOn: HowDoUseHandle!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 15:41' prior: 33554516!handlePreTest	^ Lesson title: 'handle what is is' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachineForHandle." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zipAndTestYourImage :"HowDoUseHandle testImageForHandle."If this test fails, you can load the code by loading the configurationOfHandle""ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 15:42' prior: 33555229!handlePreTest	^ Lesson title: 'handle what is is' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachineForHandle." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zipAndTestYourImage :"HowDoUseHandle testImageForHandle."If this test fails, you can load the code by loading the configurationOfHandle"ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 15:45' prior: 73273057!handleWhatIsIt	^ Lesson title: 'handle support?' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachine." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zip" AndTestYourImage :"HowDoUseHandle testImage."If this test fails, you can load the code by loading the configurationOfHandle""ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 15:45' prior: 33555928!handlePreTest	^ Lesson title: 'handle support?' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachineForHandle." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zipAndTestYourImage :"HowDoUseHandle testImageForHandle."If this test fails, you can load the code by loading the configurationOfHandle"ProfStef next.'! !Smalltalk removeClassNamed: #ProfJB!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 15:51'!handlePrinciple	^ Lesson title: 'handle principle' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachine." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zip" AndTestYourImage :"HowDoUseHandle testImage."If this test fails, you can load the code by loading the configurationOfHandle""ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 15:57' prior: 33558028!handlePrinciple	^ Lesson title: 'handle principle' lesson: '"As we say previously Handle is a special object that allow you to create indirection on Behavior or on State.This tutorial, is separate in 3 Step,	- Learn the Core model of The Handle and How to use it.	- Learn how use the different application created for the handle.	- And learn how extend Handles to create your specifique indirection on Handle.the core Model of Handle is pretty simple, is just composed of 3 classProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:13' prior: 33558712!handlePrinciple	^ Lesson title: 'handle principle' lesson: '"As we say previously Handle is a special object that allow you to create indirection on Behavior or on State.This tutorial, is separate in 3 Step,	- Learn the Core model of The Handle and How to use it.	- Learn how use the different application created for the handle.	- And learn how extend Handles to create your specifique indirection on Handle.the core Model of Handle is pretty simple, is just composed of 2 class,Handle : Handle is a object know by the VM, it''s represent a indirection, do on a object, such a transparent proxy.MetaHandle : MetaHandle is Handle which able to configure the Handle. We need this object because once we activate a handle, is become a unreachable object. Invisible From the image part.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:14'!handleFirstStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple.""If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isAa isB"That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isAhandleOfA isBProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:14' prior: 33559303!handlePrinciple	^ Lesson title: 'handle principle' lesson: '"As we say previously Handle is a special object that allow you to create indirection on Behavior or on State.This tutorial, is separate in 3 Step,	- Learn the Core model of The Handle and How to use it.	- Learn how use the different application created for the handle.	- And learn how extend Handles to create your specifique indirection on Handle.the core Model of Handle is pretty simple, is just composed of 2 class,Handle : Handle is a object know by the VM, it''s represent a indirection, do on a object, such a transparent proxy.MetaHandle : MetaHandle is Handle which able to configure the Handle. We need this object because once we activate a handle, is become a unreachable object. Invisible From the image part.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:14' prior: 33560195!handleFirstStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple.""If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isAa isB"That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isAhandleOfA isBProfStef next.'! !!HowDoUseHandle methodsFor: 'tutorial' stamp: 'JB 11/29/2010 16:15' prior: 73274411!tutorial	^ #(#handlePreTest handlePrinciple handleFirstStep)! !ProfStef goOn: HowDoUseHandle!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:15' prior: 33560788!handlePrinciple	^ Lesson title: 'handle principle' lesson: '"As we say previously Handle is a special object that allow you to create indirection on Behavior or on State.This tutorial, is separate in 3 Step,	- Learn the Core model of The Handle and How to use it.	- Learn how use the different application created for the handle.	- And learn how extend Handles to create your specifique indirection on Handle.the core Model of Handle is pretty simple, is just composed of 2 class,Handle : Handle is a object know by the VM, it''s represent a indirection, do on a object, such a transparent proxy.MetaHandle : MetaHandle is Handle which able to configure the Handle. We need this object because once we activate a handle, is become a unreachable object. Invisible From the image part.""ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:15' prior: 33562482!handlePrinciple	^ Lesson title: 'handle principle' lesson: '"As we say previously Handle is a special object that allow you to create indirection on Behavior or on State.This tutorial, is separate in 3 Step,	- Learn the Core model of The Handle and How to use it.	- Learn how use the different application created for the handle.	- And learn how extend Handles to create your specifique indirection on Handle.the core Model of Handle is pretty simple, is just composed of 2 class,Handle : Handle is a object know by the VM, it''s represent a indirection, do on a object, such a transparent proxy.MetaHandle : MetaHandle is Handle which able to configure the Handle. We need this object because once we activate a handle, is become a unreachable object. Invisible From the image part."ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:16' prior: 33561687!handleFirstStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple."|a handleOfA|"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isAa isB"That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isAhandleOfA isBProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:16' prior: 33564349!handleFirstStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple."|a handleOfA|"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:16' prior: 33565023!handleFirstStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple."|a handleOfA|"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:16' prior: 33565635!handleFirstStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B"!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:18' prior: 33566246!handleFirstStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:18' prior: 33568540!handleFirstStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:18'!handleSecondStep	^ Lesson title: 'handle principle' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:19' prior: 33569152!handleFirstStep	^ Lesson title: 'handle first Indirection' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:19' prior: 33570357!handleFirstStep	^ Lesson title: 'handle first indirection' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:19' prior: 33569746!handleSecondStep	^ Lesson title: 'handle modification' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:21' prior: 33571593!handleSecondStep	^ Lesson title: 'handle modification' lesson: '"The API for using handle is very simple."|a handleOfA |"a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B"a == handleOfA."That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:23' prior: 33572207!handleSecondStep	^ Lesson title: 'handle modification' lesson: '"The API for using handle is very simple."|a handleOfA |"a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:26' prior: 33573042!handleSecondStep	^ Lesson title: 'handle modification' lesson: '"The API for using handle is very simple."|a handleOfA |"a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference""That mean all the message send to a will be execute with method dictionnary of A"a var1"That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:28' prior: 33573974!handleSecondStep	^ Lesson title: 'handle modification' lesson: '"The API for using handle is very simple."|a handleOfA |"a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:28' prior: 33574899!handleSecondStep	^ Lesson title: 'handle modification' lesson: '"The API for using handle is very simple."|a handleOfA |"a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on ''a'' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:29' prior: 33575828!handleSecondStep	^ Lesson title: 'handle modification' lesson: '"The API for using handle is very simple."|a handleOfA |"a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on ''a'' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:29'!handleThirdStep	^ Lesson title: 'handle modification' lesson: '"The API for using handle is very simple."|a handleOfA |"a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on ''a'' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:30' prior: 33577578!handleThirdStep	^ Lesson title: 'handle ' lesson: '"The API for using handle is very simple.""a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on ''a'' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"|a handleOfA |a := A new.handleOfA := Handle for: a to: AA. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:30' prior: 33576773!handleSecondStep	^ Lesson title: 'handle ' lesson: '"The API for using handle is very simple.""a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on ''a'' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"|a handleOfA |a := A new.handleOfA := Handle for: a to: AA. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:31' prior: 33578398!handleThirdStep	^ Lesson title: 'handle ' lesson: '"The other skill of the handle is to create indirection on StateProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:36' prior: 33580141!handleThirdStep	^ Lesson title: 'handle ' lesson: '"The other skill of the handle is to create indirection on StateThat mean you can create a Handle, which keep this own state."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:37'!handleFourStep	^ Lesson title: 'handle ' lesson: '"The other skill of the handle is to create indirection on StateThat mean you can create a Handle, which keep this own state."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:39' prior: 33580631!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All Handle API.			"ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:53' prior: 33580361!handleThirdStep	^ Lesson title: 'handle ' lesson: '"The other skill of the handle is to create indirection on StateThat mean you can create a Handle, which keep this own state."|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:53' prior: 33581162!handleThirdStep	^ Lesson title: 'handle ' lesson: '"The other skill of the handle is to create indirection on StateThat mean you can create a Handle, which keep this own state."|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/29/2010 16:53' prior: 33581597!handleThirdStep	^ Lesson title: 'handle ' lesson: '"The other skill of the handle is to create indirection on StateThat mean you can create a Handle, which keep this own state.try"|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'tutorial' stamp: 'JB 11/29/2010 16:54' prior: 33562284!tutorial	^ #(#handlePreTest handlePrinciple handleFirstStep handleSecondStep handleTHirdStep)! !!HowDoUseHandle methodsFor: 'tutorial' stamp: 'JB 11/29/2010 16:54' prior: 33582471!tutorial	^ #(#handlePreTest handlePrinciple handleFirstStep handleSecondStep handleThirdStep)! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: 'test'.handleOfA var1 = 'test'.handleOfA var1: 'test2'.a var1 = 'test2'.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: 'test'.handleOfA var1 = 'test'.handleOfA var1: 'test2'.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: 'test'.handleOfA var1 = 'test'.handleOfA var1: 'test2'.a var1 = 'test2'.!ProfStef next.!|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: 'test'.handleOfA var1 = 'test'.!|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: 'test'.handleOfA var1 = 'test'.handleOfA var1: 'test2'.!|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: 'test'.handleOfA var1 = 'test'.handleOfA var1: 'test2'.a var1 = 'test2'.!ProfStef next.!ProfStef next.!----SNAPSHOT----an Array(29 November 2010 4:55:46 pm) Handle-Image.TEST.image priorSource: 22932370!----SNAPSHOT----an Array(29 November 2010 4:57:26 pm) Handle-Image.TEST.image priorSource: 30029!----SNAPSHOT----an Array(29 November 2010 5:19:23 pm) Handle-Image.TEST.image priorSource: 30131!----QUIT----an Array(29 November 2010 5:19:26 pm) Handle-Image.TEST.image priorSource: 30230!----STARTUP----an Array(30 November 2010 11:14:46 am) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: 'test'.handleOfA var1 = 'test'.!|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: 'test'.handleOfA var1 = 'test'.handleOfA var1.!ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 12:42' prior: 33570975!handleFirstStep	^ Lesson title: 'handle first indirection' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 12:43' prior: 33579269!handleSecondStep	^ Lesson title: 'handle ' lesson: '"The API for using handle is very simple.""a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on ''a'' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 12:51' prior: 33580916!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic access(Handle class>>#for:) => create a Handle that do indirection on state of the object.(Handle class>>#for:to:) => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration(Handle class>>#createHandle) => create a non activate handle, which your are able to configure using the configuration interface.(Handle class>>#debugFor:to:) => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the indirection."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 12:55' prior: 33587022!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic access(Handle class>>#for:) => create a Handle that do indirection on state of the object.(Handle class>>#for:to:) => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) "Handle debugFor: (Object new) to: Class => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.accessor"ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:03' prior: 33587808!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic access(Handle class>>#for:) => create a Handle that do indirection on state of the object.(Handle class>>#for:to:) => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection."accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior//removeBehavior => enable/disable the behavior indirection.addState//removeState => enable/disable the state indirection.addSelfWrapping//addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:11' prior: 33588526!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.(Handle for: (Object new) to: Class) => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection."accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior//removeBehavior => enable/disable the behavior indirection.addState//removeState => enable/disable the state indirection.addSelfWrapping//addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:11' prior: 33589973!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection."accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior//removeBehavior => enable/disable the behavior indirection.addState//removeState => enable/disable the state indirection.addSelfWrapping//addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:17' prior: 33591436!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection."accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:19' prior: 33592897!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection."accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver."Activate Handleis do by sending the message becomeHandle to a unactivate handle.Handle debugFor: (Object new);	classLookup: Object;	addBehavior;	removeState;	becomeHandle."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:21' prior: 33594361!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection."accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Object;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new);	classLookup: Object;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle debugFor: (Object new) to: Class"ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:21' prior: 33596006!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection."accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle debugFor: (Object new) to: Class."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:22' prior: 33597859!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection."accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Class."ProfStef next.'! !!HowDoUseHandle methodsFor: 'tutorial' stamp: 'JB 11/30/2010 13:22' prior: 33582654!tutorial	^ #(#handlePreTest handlePrinciple handleFirstStep handleSecondStep handleThirdStep handleFourStep)! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:22' prior: 33599711!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class => create a handle that do indirection on behavior of the object redirect to the class.Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Class."ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:25' prior: 33601873!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new)  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new) " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Class."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:25' prior: 33603902!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :	All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Class."ProfStef next.'! !ProfStef next.!"The API for using handle is very simple."!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:25' prior: 33605752!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Class."ProfStef next.'! !!Handle class methodsFor: 'newStuff' stamp: 'JB 11/30/2010 13:27'!debugFor: aObject	| handle |	handle := self createHandle.		^ handle! !!Handle class methodsFor: 'newStuff' stamp: 'JB 11/30/2010 13:27' prior: 33609542!debugFor: aObject	| handle |	handle := self createHandle.	handle addState.	^ handle! !| handle |	handle := self createHandle.	handle addState.!!Handle class methodsFor: 'newStuff' stamp: 'JB 11/30/2010 13:27' prior: 33609700!debugFor: aObject	| handle |	handle := self createHandle.		handle addState.	^ handle! !!Handle class methodsFor: 'newStuff' stamp: 'JB 11/30/2010 13:27' prior: 33609935!debugFor: aObject	| handle |	handle := self createHandle.	handle receiver: aObject.	handle addState.	^ handle! !!Handle class methodsFor: 'newStuff' stamp: 'JB 11/30/2010 13:27' prior: 33610111!debugFor: aObject	| handle |	handle := self createHandle.	handle receiver: aObject.	handle addState.	^ handle! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!(Handle debugFor: (Object new))	classLookup: Class;	addBehavior;	removeState;	becomeHandle.!(Handle debugFor: (Object new))!(Handle debugFor: (Object new))	classLookup: Class!(Handle debugFor: (Object new))	classLookup: Class;	addBehavior!(Handle debugFor: (Object new))	classLookup: Class;	addBehavior;	removeState!(Handle debugFor: (Object new))	classLookup: Class;	addBehavior;	removeState;	becomeHandle.!(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	removeState;	becomeHandle.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:30' prior: 33607702!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new)	classLookup: Class;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Class.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:30' prior: 33611168!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new)	classLookup: Object;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Class.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:30' prior: 33613012!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Class;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new)	classLookup: Object;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Object.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:30' prior: 33614857!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Object;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"Handle debugFor: (Object new)	classLookup: Object;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Object.ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:30' prior: 33616703!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."Handle debugFor: (Object new);	classLookup: Object;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Object.ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	removeState;	becomeHandle.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:31' prior: 33618667!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Object.ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	becomeHandle.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:50'!handleMeta	^ Lesson title: 'Small like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:51' prior: 33622768!handleMeta	^ Lesson title: 'Small like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"mtaH classLookup: A.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:54' prior: 33623472!handleMeta	^ Lesson title: 'Small like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB.metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: ''state save''.handle var1.metaH removeState.handle var1.metaH addState.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:55' prior: 33624317!handleMeta	^ Lesson title: 'Small like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB.metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: ''state save''.handle var1.metaH removeState.handle var1.metaH addState.handle var1."Be care to not lost the Reference MetaHandle or you can not changing the handle anymore !!!!"ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 13:55' prior: 33625308!handleMeta	^ Lesson title: 'Small like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB.metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: ''state save''.handle var1.metaH removeState.handle var1.metaH addState.handle var1."Be care to not lost the Reference MetaHandle or you can not changing the handle anymore !!!!""It''s enough for the core of Handle"ProfStef next.'! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B"!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.!ProfStef next.!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'tutorial' stamp: 'JB 11/30/2010 14:04' prior: 33601560!tutorial	^ #(#handlePreTest handlePrinciple handleFirstStep handleSecondStep handleThirdStep handleFourStep handleMeta)! !ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.!|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on 'a' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.!ProfStef next.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA.a class!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA.a class.handleOfA class!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: 'test'.handleOfA var1 = 'test'.handleOfA var1: 'test2'.a var1 = 'test2'.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: 'test'.handleOfA var1 = 'test'.handleOfA var1: 'test2'.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: 'test'.handleOfA var1 = 'test'.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: 'test'.!|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. !|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on 'a' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 14:06' prior: 33626403!handleMeta	^ Lesson title: 'Smell like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB.metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: ''state save''.handle var1.metaH removeState.handle var1.metaH addState.handle var1."Be care to not lost the Reference MetaHandle or you can not changing the handle anymore !!!!""It''s enough for the core of Handle"ProfStef next.'! !|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.!|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.!|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: 'state save'.handle var1.metaH removeState.handle var1.metaH addState.handle var1.!|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: 'state save'.handle var1.metaH removeState.handle var1.metaH addState.!|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: 'state save'.handle var1.metaH removeState.handle var1.!|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: 'state save'.handle var1.metaH removeState.!|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1.metaH addState.handle var1: 'state save'.handle var1.!|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1.!!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 14:10' prior: 33633197!handleMeta	^ Lesson title: 'Smell like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1. "''var1''"metaH addState.handle var1: ''state save''.handle var1." ''state save''"metaH removeStatehandle var1." ''var1''"metaH addState.handle var1. "''state save''""Be care to not lost the Reference MetaHandle or you can not changing the handle anymore !!!!""It''s enough for the core of Handle"ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 11/30/2010 14:10' prior: 33637075!handleMeta	^ Lesson title: 'Smell like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1. "''var1''"metaH addState.handle var1: ''state save''.handle var1.  "''state save''"metaH removeStatehandle var1."  ''var1''"metaH addState.handle var1.  "''state save''""Be care to not lost the Reference MetaHandle or you can not changing the handle anymore !!!!""It''s enough for the core of Handle"ProfStef next.'! !!HowDoUseHandle class methodsFor: 'no messages' stamp: 'JB 11/30/2010 14:11'!testImageForHandle! !	Smalltalk specialObjectsArray !SmalltalkImage!	SmalltalkImage current specialObjectsArray !	SmalltalkImage current specialObjectsArray !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:12' prior: 33639449!testImageForHandle	^(SmalltalkImage current specialObjectsArray at: 51 == Handle)! !((SmalltalkImage current specialObjectsArray at: 51) == Handle)!!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:13' prior: 33639721!testImageForHandle	^((SmalltalkImage current specialObjectsArray at: 51) == Handle)! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:13' prior: 33639975!testImageForHandle	^((SmalltalkImage current specialObjectsArray at: 51) == Handle)! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:13' prior: 33640165!testImageForHandle	^((SmalltalkImage current specialObjectsArray at: 51) == Handle) on: Error do:[False]! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:13' prior: 33640355!testImageForHandle	^((SmalltalkImage current specialObjectsArray at: 51) == Handle) on: Error do:[false]! !	"SmalltalkImage current getVMParameters"!SmalltalkImage current getVMParameters!ProfStef goOn: HowDoUseHandle!(Handle new) becomeHandle !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:24'!testVirtualMachineForHandle	^((Handle new) becomeHandle) on: Error do: [false]! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:24' prior: 33640907!testVirtualMachineForHandle	((Handle new) becomeHandle) on: Error do: [^false].	^true.! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:25' prior: 33641092!testVirtualMachineForHandle	[(Handle new) becomeHandle] on: Error do: [^false].	^true.! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 14:25' prior: 33640566!testImageForHandle	^[(SmalltalkImage current specialObjectsArray at: 51) == Handle] on: Error do:[false]! !HowDoUseHandle testVirtualMachineForHandle.!HowDoUseHandle testVirtualMachineForHandle.!HowDoUseHandle testImageForHandle.!----SNAPSHOT----an Array(30 November 2010 2:25:35 pm) Handle-Image.TEST.image priorSource: 30329!----QUIT----an Array(30 November 2010 2:25:38 pm) Handle-Image.TEST.image priorSource: 87288!----STARTUP----an Array(30 November 2010 2:25:59 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!ProfStef goOn: HowDoUseHandle!HowDoUseHandle testVirtualMachineForHandle.!HowDoUseHandle testImageForHandle.!HowDoUseHandle testImageForHandle.!HowDoUseHandle testVirtualMachineForHandle.!ProfStef next.!ProfStef next.!ProfStef next.!----QUIT/NOSAVE----an Array(30 November 2010 2:33:18 pm) Handle-Image.TEST.image priorSource: 87387!----STARTUP----an Array(30 November 2010 2:33:23 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!----SNAPSHOT----an Array(30 November 2010 3:06:43 pm) Handle-Image.TEST.image priorSource: 87387!ProfStef goOn: HowDoUseHandle!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!ProfStef next.!----SNAPSHOT----an Array(30 November 2010 3:42:12 pm) Handle-Image.TEST.image priorSource: 88215!----SNAPSHOT----an Array(30 November 2010 3:42:17 pm) Handle-Image.TEST.image priorSource: 88517!"Handles"!----QUIT/NOSAVE----an Array(30 November 2010 3:44:48 pm) Handle-Image.TEST.image priorSource: 88616!----STARTUP----an Array(30 November 2010 3:45:02 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!collection!"Handles"!!Handle class methodsFor: 'newStuff' stamp: 'JB 11/30/2010 15:46' prior: 73123188!debugFor: aObject to: aClass 	| handle |	handle := self createHandle.	handle initializeHandleWith: aObject to: aClass.	^ handle! !!Handle class methodsFor: 'newStuff' stamp: 'JB 11/30/2010 15:47' prior: 73122913!for: aObject 	| handle |	handle := self debugFor: aObject to: nil.	handle removeBehavior; addState.	handle becomeHandle.	^ handle! !!Handle class methodsFor: 'newStuff' stamp: 'JB 11/30/2010 15:48' prior: 73122615!for: aObject to: aClass 	| handle |	handle := self debugFor: aObject to: aClass.	handle addBehavior.	handle becomeHandle.	^ handle! !!Handle methodsFor: 'accessing' stamp: 'JB 11/30/2010 15:49' prior: 47054883!classLookup: aClass 	classLookup := aClass! !!Handle methodsFor: 'initialize-release' stamp: 'JB 11/30/2010 15:50' prior: 70721588!initializeHandleWith: aObject to: aClass 	| size |	receiver := aObject.	classLookup := aClass.	size := aObject class allInstVarNames size.	state := Array new: size.	1		to: size		do: [:index | state				at: index				put: (aObject instVarAt: index)]! !!Handle methodsFor: 'accessing' stamp: 'JB 11/30/2010 15:50' prior: 47069694!receiver: aObject 	receiver := aObject! !----SNAPSHOT----an Array(30 November 2010 3:50:41 pm) Handle-Image.TEST.image priorSource: 88616!MetaHandle removeSelector: #addMethod:!!MetaHandle class methodsFor: 'accessing' stamp: 'JB 11/30/2010 15:51' prior: 73174701!for: aHandle	^ self for: aHandle  to: self! !----SNAPSHOT----an Array(30 November 2010 3:51:44 pm) Handle-Image.TEST.image priorSource: 90231!----STARTUP----an Array(30 November 2010 3:52:31 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!!ClassHandleTest methodsFor: 'testing' stamp: 'JB 11/30/2010 15:53'!expectedFailures	! !!ClassHandleTest methodsFor: 'testing' stamp: 'JB 11/30/2010 15:53' prior: 33645230!expectedFailures	self halt.! !----STARTUP----an Array(30 November 2010 3:53:46 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!Handle compileAll!Handle class compileAll!Handle compileAll.Handle class compileAll.MetaHandle compileAll.MetaHandle class compileAll.!!ClassHandleTest methodsFor: 'testing' stamp: 'JB 11/30/2010 15:56' prior: 70895372!testAddInstVarName	| classHandle |	classHandle := ClassHandle for: A.	classHandle addInstVarName: 'x'.	self assert: classHandle instVarNames = #('x' ).	classHandle addInstVarName: 'y'.	self assert: classHandle instVarNames = #('x' 'y' )! !!ClassHandleTest methodsFor: 'functional test' stamp: 'JB 11/30/2010 15:57' prior: 73266551!testCreationMethodOnHandle	| rewriteMethodHandle propagationHandle lookUp |	propagationHandle := PropagationTestClass new.	rewriteMethodHandle := RewriteMethodWithPropagationHandle				debugFor: propagationHandle				rule: [].	lookUp := rewriteMethodHandle classLookup.	rewriteMethodHandle becomeHandle.	lookUp compile: 'testToRemove ^false'.	self		shouldnt: [rewriteMethodHandle testToRemove]		raise: MessageNotUnderstood.	self		should: [propagationHandle testToRemove]		raise: MessageNotUnderstood! !!ClassHandleTest methodsFor: 'functional test' stamp: 'JB 11/30/2010 15:57' prior: 33646062!testCreationMethodOnHandle	| rewriteMethodHandle propagationHandle lookUpClass |	propagationHandle := PropagationTestClass new.	rewriteMethodHandle := RewriteMethodWithPropagationHandle				debugFor: propagationHandle				rule: [].	lookUpClass := rewriteMethodHandle classLookup.	rewriteMethodHandle becomeHandle.	lookUpClass compile: 'testToRemove ^false'.	self		shouldnt: [rewriteMethodHandle testToRemove]		raise: MessageNotUnderstood.	self		should: [propagationHandle testToRemove]		raise: MessageNotUnderstood! !.ClassHandleTest compileAll.!ClassHandleTest class compileAll.!----STARTUP----an Array(30 November 2010 4:00:20 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!StructuralHandleClass!ClassHandle for: A.!----STARTUP----an Array(30 November 2010 4:02:50 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!!ClassHandleTest methodsFor: 'functional test' stamp: 'JB 11/30/2010 16:03'!expectedFailures	^#(testCreationMethodOnHandle).! !----SNAPSHOT----an Array(30 November 2010 4:03:50 pm) Handle-Image.TEST.image priorSource: 90506!----STARTUP----an Array(30 November 2010 4:04:12 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!!ClassHandleTest methodsFor: 'functional test' stamp: 'JB 11/30/2010 16:04' prior: 33647639!expectedFailures	^#(#testCreationMethodOnHandle).! !----STARTUP----an Array(30 November 2010 4:04:53 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!!ClassHandleTest methodsFor: 'functional test' stamp: 'JB 11/30/2010 16:04' prior: 73266551!testCreationMethodOnHandle	"| t1 t2 t3 t4 |	t3 := PropagationTestClass new.	t1 := RewriteMethodWithPropagationHandle				debugFor: t3				rule: [].	t4 := t1 classLookup.	t1 becomeHandle.	t4 compile: 'testToRemove ^false'.	self		shouldnt: [t1 testToRemove]		raise: MessageNotUnderstood.	self		should: [t3 testToRemove]		raise: MessageNotUnderstood"! !!ClassHandleTest methodsFor: 'functional test' stamp: 'JB 11/30/2010 16:05' prior: 33647639!expectedFailures	^#(#testCreationMethodOnHandle).! !----SNAPSHOT----an Array(30 November 2010 4:05:49 pm) Handle-Image.TEST.image priorSource: 93259!!ClassHandleTest methodsFor: 'testing' stamp: 'JB 11/30/2010 16:06' prior: 70895372!testAddInstVarName	| classHandle |	classHandle := ClassHandle for: A.	classHandle addInstVarName: 'x'.	self assert: classHandle instVarNames = #('x' ).	classHandle addInstVarName: 'y'.	self assert: classHandle instVarNames = #('x' 'y' )! !----SNAPSHOT----an Array(30 November 2010 4:06:08 pm) Handle-Image.TEST.image priorSource: 94354!!ClassHandleTest methodsFor: 'setup' stamp: 'JB 11/30/2010 16:06' prior: 70892671!deleteRenamedClass	| mustRemove |	mustRemove := Smalltalk globals				at: renamedName				ifAbsent: [^ self].	mustRemove removeFromChanges; removeFromSystemUnlogged! !!ClassHandleTest methodsFor: 'setup' stamp: 'JB 11/30/2010 16:06' prior: 70892468!deleteClass	| mustRemove |	mustRemove := Smalltalk globals				at: className				ifAbsent: [^ self].	mustRemove removeFromChanges; removeFromSystemUnlogged! !Smalltalk removeClassNamed: #CopyHandleTest!!HandleBehaviorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:07' prior: 70738722!testInterceptMessage	| handle |	handle := Handle debugFor: A new to: B.	handle addBehavior; removeState; becomeHandle.	self assert: handle testReturn = 'success'! !!HandleBehaviorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:07' prior: 70738064!testdontChangeOriginalObject	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeState; becomeHandle.	self assert: trueObject isA.	self deny: trueObject isB.	self assert: handle isB.	self deny: handle isA! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:10' prior: 70741139!testIdentityObject1	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:10' prior: 70741429!testIdentityObject2	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:10' prior: 70741716!testIdentityObject3	| trueObject t2 |	trueObject := A new.	t2 := Handle debugFor: trueObject to: B.	t2 removeBehavior; addState; becomeHandle.	self assert: trueObject == t2! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:10' prior: 70742003!testIdentityObject4	| trueObject t2 |	trueObject := A new.	t2 := Handle debugFor: trueObject to: B.	t2 removeBehavior; removeState; becomeHandle.	self assert: trueObject == t2! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:10' prior: 33651486!testIdentityObject4	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:11' prior: 33651205!testIdentityObject3	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; addState; becomeHandle.	self assert: trueObject == handle! !!HandleStateTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:11' prior: 70743938!testChangingStateOrigine	| t1 handle |	t1 := A new.	handle := Handle debugFor: t1 to: B.	handle removeBehavior; addState; becomeHandle.	t1 var1: 'test'.	self deny: handle var1 = 'test'! !!PropagationTest methodsFor: 'functional test' stamp: 'JB 11/30/2010 16:12' prior: 47918732!testCreationMethodOnOriginate	"| t1 t2 t3 |	t3 := PropagationTestClass new.	t1 := RewriteMethodWithPropagationHandle				for: t3				rule: [].	PropagationTestClass compile: 'testToRemove ^false'.	self		should: [t1 testToRemove]		raise: MessageNotUnderstood.	self		shouldnt: [t3 testToRemove]		raise: MessageNotUnderstood"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 11/30/2010 16:12' prior: 47798008!testInstVar"	| t1 t2 |	t2 := #instanceVar.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 11/30/2010 16:12' prior: 47797514!testSelf"	| t1 t2 |	t2 := #self.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 11/30/2010 16:12' prior: 47792426!testSendToInstVar"	| t1 t2 |	t2 := #sendToInstanceVar.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 11/30/2010 16:12' prior: 47797007!testSendToSelf"	| t1 t2 |	t2 := #sendToSelf.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 11/30/2010 16:12' prior: 47796498!testSendToSuper"	| t1 t2 |	t2 := #sendToSuper.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 11/30/2010 16:12' prior: 47795992!testSendToTemp"	| t1 t2 |	t2 := #sendToTemp.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 11/30/2010 16:12' prior: 47795498!testTemp"	| t1 t2 |	t2 := #temp.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!HandleSelfWrappingTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:13' prior: 73138745!testDesactiveSelfWrap	| t1 handle |	t1 := A new.	handle := Handle debugFor: t1 to: B.	handle addBehavior; removeSelfWrapping; becomeHandle.	self		should: [handle activeTestWrap]		raise: MessageNotUnderstood! !!HandleSelfWrappingTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:13' prior: 73139089!testActiveSelfWrap	| t1 handle |	t1 := A new.	handle := Handle debugFor: t1 to: B.	handle addBehavior; addSelfWrapping; becomeHandle.	self		shouldnt: [handle activeTestWrap]		raise: MessageNotUnderstood! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:14' prior: 70759027!testUseStateThenStopToUseIt	| handle meta trueObject |	trueObject := AA new.	handle := (Handle debugFor: trueObject to: A) addBehavior; addState.	meta := MetaHandle for: handle.	handle becomeHandle.	handle var1: 'testHandle'.	self assert: handle var1 = 'testHandle'.	meta removeState.	self deny: handle var1 = 'testHandle'.	self assert: trueObject var1 = handle var1.	meta addState.	self assert: handle var1 = 'testHandle'! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:14' prior: 70743486!testStoreIntoTempReference2	| handle |	handle := (Handle debugFor: A new to: B) addBehavior; addState; becomeHandle.	self assert: handle isB.	self deny: handle isA! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:14' prior: 70743201!testStoreIntoTempReference	| handle |	handle := (Handle debugFor: A new to: B) addBehavior; removeState; becomeHandle.	self assert: handle isB.	self deny: handle isA! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:15' prior: 70760574!testRemoveTwice	| handle trueObject |	trueObject := AA new.	handle := (Handle debugFor: trueObject to: A) addBehavior; addState.	handle removeState.	handle removeState.	self assert: handle configuration = 2.	handle removeBehavior.	handle removeBehavior.	self assert: handle configuration = 0! !!HandleSelfWrappingTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:15' prior: 33656177!testDesactiveSelfWrap	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeSelfWrapping; becomeHandle.	self		should: [handle activeTestWrap]		raise: MessageNotUnderstood! !!HandleSelfWrappingTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:15' prior: 33656498!testActiveSelfWrap	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; addSelfWrapping; becomeHandle.	self		shouldnt: [handle activeTestWrap]		raise: MessageNotUnderstood! !!HandleStateTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:15' prior: 33652364!testChangingStateOrigine	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; addState; becomeHandle.	trueObject var1: 'test'.	self deny: handle var1 = 'test'! !PackageInfo named: 'Handles'!(PackageInfo named: 'Handles') classes!----SNAPSHOT----an Array(30 November 2010 4:17:25 pm) Handle-Image.TEST.image priorSource: 94784!((PackageInfo named: 'Handles') classes) do:[:each | each compileAll.]!!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:17' prior: 70744236!var1: aObject 	var1 := aObject! !!CapabilityTestClass methodsFor: 'public' stamp: 'JB 11/30/2010 16:18' prior: 73150108!storeAndReturnSelf	| aObject |	aObject := self.	^ aObject! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:22' prior: 70821458!changeStaticHierarchy: aMethodDict to: aClass aMethodDict		do: [:each | each methodClass: aClass].	^ methodDict! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:23' prior: 70835048!debugMirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject with: self methodDict.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior.	^ handle! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:23' prior: 70835387!mirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject with: self methodDict.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior; becomeHandle.	^ handle! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:25' prior: 70833099!reflect: aObject with: useless  	| aBehavior  aMethodDict |	aMethodDict  := aObject class methodDict copy.	aMethodDict		addAll: (self changeStaticHierarchy: self methodDict copy to: aObject class).	aBehavior := Behavior new setFormat: aObject class format;				 superclass: aObject class superclass;				 methodDict: aMethodDict.	aBehavior superclass: aObject class.	^ aBehavior! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:26'!reflect: aObject	| aBehavior  aMethodDict |	aMethodDict  := aObject class methodDict copy.	aMethodDict		addAll: (self changeStaticHierarchy: self methodDict copy to: aObject class).	aBehavior := Behavior new setFormat: aObject class format;				 superclass: aObject class superclass;				 methodDict: aMethodDict.	aBehavior superclass: aObject class.	^ aBehavior! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:26' prior: 33660343!mirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior; becomeHandle.	^ handle! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:26' prior: 33660042!debugMirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior.	^ handle! !AbstractMirrorHandle class removeSelector: #reflect:with:!----SNAPSHOT----an Array(30 November 2010 4:27:12 pm) Handle-Image.TEST.image priorSource: 104833!!TranscriptWatcher class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:28' prior: 73212884!InitializeWatcherFor: aObject 	| t2 t3 |	t3 := RBParseTreeRewriter new.	t3 replaceMethod: self detectRule with: self replaceRule.	t2 := Behavior new setFormat: aObject class format;				 superclass: aObject class;				 methodDict: MethodDictionary new.	aObject class methodDict		do: [:t4 | 			| t5 |			t5 := t3						executeTree: (RBParser parseMethod: t4 getSource);						 tree.			t2 compile: t5 formattedCode].	^ t2! !!TranscriptWatcher class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:28' prior: 33662339!InitializeWatcherFor: aObject 	| t2 t3 |	t3 := RBParseTreeRewriter new.	t3 replaceMethod: self detectRule with: self replaceRule.	t2 := Behavior new setFormat: aObject class format;				 superclass: aObject class;				 methodDict: MethodDictionary new.	aObject class methodDict		do: [:method | 			| t5 |			t5 := t3						executeTree: (RBParser parseMethod: method getSource);						 tree.			t2 compile: t5 formattedCode].	^ t2! !!TranscriptWatcher class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:28' prior: 33662876!InitializeWatcherFor: aObject 	| t2 t3 |	t3 := RBParseTreeRewriter new.	t3 replaceMethod: self detectRule with: self replaceRule.	t2 := Behavior new setFormat: aObject class format;				 superclass: aObject class;				 methodDict: MethodDictionary new.	aObject class methodDict		do: [:method | 			| tree |			tree := t3						executeTree: (RBParser parseMethod: method getSource);						 tree.			t2 compile: tree formattedCode].	^ t2! !!TranscriptWatcher class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:29' prior: 33663421!InitializeWatcherFor: aObject 	| behavior treeRewriter |	treeRewriter := RBParseTreeRewriter new.	treeRewriter replaceMethod: self detectRule with: self replaceRule.	behavior := Behavior new setFormat: aObject class format;				 superclass: aObject class;				 methodDict: MethodDictionary new.	aObject class methodDict		do: [:method | 			| tree |			tree := treeRewriter						executeTree: (RBParser parseMethod: method getSource);						 tree.			behavior compile: tree formattedCode].	^ behavior! !!Watcher class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:30' prior: 73176584!watch: aObject 	| watcher aClass meta |	watcher := self new.	aClass := self InitializeWatcherFor: aObject.	watcher become: aObject.	meta := MetaWatcher for: aObject.	aObject classLookup: aClass.	aObject addBehavior.	aObject receiver: watcher.	aObject becomeHandle.	^ meta! !!Watcher class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:30' prior: 73165254!InitializeWatcherFor: aObject 	^ aObject class! !----SNAPSHOT----an Array(30 November 2010 4:30:55 pm) Handle-Image.TEST.image priorSource: 107701!((PackageInfo named: 'Handles') classes) do:[:each | each compileAll.]!----SNAPSHOT----an Array(30 November 2010 4:35:06 pm) Handle-Image.TEST.image priorSource: 110575!----SNAPSHOT----an Array(30 November 2010 4:35:27 pm) Handle-Image.TEST.image priorSource: 110748!!SmalltalkImage methodsFor: '*handles' stamp: 'JB 11/30/2010 16:40'!recreateSpecialObjectsArrayForHandle	| array |	array := Array new: 51.	array at: 1 put: nil. 	array at: 2 put: false.	array at: 3 put: true.	array		at: 4		put: (self associationAt: #Processor).	array at: 5 put: Bitmap.	array at: 6 put: SmallInteger.	array at: 7 put: ByteString.	array at: 8 put: Array.	array at: 9 put: Smalltalk.	array at: 10 put: Float.	array at: 11 put: MethodContext.	array at: 12 put: BlockContext.	array at: 13 put: Point.	array at: 14 put: LargePositiveInteger.	array at: 15 put: Display.	array at: 16 put: Message.	array at: 17 put: CompiledMethod.	array		at: 18		put: (self specialObjectsArray at: 18).	array at: 19 put: Semaphore.	array at: 20 put: Character.	array at: 21 put: #doesNotUnderstand:.	array at: 22 put: #cannotReturn:.	array at: 23 put: nil.	array at: 24 put: #(#+ 1 #- 1 #< 1 #> 1 #'<=' 1 #'>=' 1 #= 1 #'~=' 1 #* 1 #/ 1 #'\\' 1 #@ 1 #bitShift: 1 #'//' 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #'==' 1 #class 0 #blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	array		at: 25		put: ((0 to: 255)				collect: [:t2 | Character value: t2]).	array at: 26 put: #mustBeBoolean.	array at: 27 put: ByteArray.	array at: 28 put: Process.	array at: 29 put: self compactClassesArray.	array		at: 30		put: (self specialObjectsArray at: 30).	array		at: 31		put: (self specialObjectsArray at: 31).	array		at: 32		put: (Float new: 2).	array		at: 33		put: (LargePositiveInteger new: 4).	array at: 34 put: Point new.	array at: 35 put: #cannotInterpret:.	array		at: 36		put: (self specialObjectsArray at: 36).	array at: 37 put: BlockClosure.	array		at: 38		put: (self specialObjectsArray at: 38).	array		at: 39		put: (self specialObjectsArray at: 39).	array at: 40 put: PseudoContext.	array		at: 42		put: ((self specialObjectsArray at: 42)				ifNil: [Semaphore new]).	array at: 43 put: LargeNegativeInteger.	array		at: 44		put: (self				at: #ExternalAddress				ifAbsent: []).	array		at: 45		put: (self				at: #ExternalStructure				ifAbsent: []).	array		at: 46		put: (self				at: #ExternalData				ifAbsent: []).	array		at: 47		put: (self				at: #ExternalFunction				ifAbsent: []).	array		at: 48		put: (self				at: #ExternalLibrary				ifAbsent: []).	array at: 49 put: #aboutToReturn:through:.	array at: 50 put: #run:with:in:.	array at: 51 put: Handle.	self specialObjectsArray become: array! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'JB 11/30/2010 16:52' prior: 47063922!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used	by the virtual machine. Its contents are critical and	unchecked, so don't even think of playing here unless you	know what you are doing."	| newArray |	newArray := Array new: 50.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	"array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	"newArray at: 41 put: TranslatedMethod."	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !----SNAPSHOT----an Array(30 November 2010 4:52:57 pm) Handle-Image.TEST.image priorSource: 110848!SystemDictionary removeSelector: #recreateSpecialObjectsArray!((PackageInfo named: 'Handles') classes) do:[:each | each compileAll.]!MetaWatcher compileAll!MetaWatcher compileAll.MetaWatcher class compileAll!!MetaWatcher methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:55' prior: 73177133!unWatch	self receiver become: self! !!MetaWatcher methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:56' prior: 73169724!isMeta	^ true! !!MetaWatcher methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:56' prior: 33672483!isMeta	^ true! !!MyBeeper methodsFor: 'play interface' stamp: 'JB 11/30/2010 16:56' prior: 73268055!play	SoundService default beep! !!MyBeeper class methodsFor: 'beeping' stamp: 'JB 11/30/2010 16:56' prior: 73268306!beep	self default 		ifNil: [self beepPrimitive]		ifNotNil: [self default play]! !!MyBeeper class methodsFor: 'beeping' stamp: 'JB 11/30/2010 16:57' prior: 73268710!beepPrimitive	SoundSettings soundEnabled 		ifTrue: [self primitiveBeep]! !!MyBeeper class methodsFor: 'customize' stamp: 'JB 11/30/2010 16:57' prior: 73269052!clearDefault	default := nil ! !!MyBeeper class methodsFor: 'customize' stamp: 'JB 11/30/2010 16:57' prior: 73269464!newDefault	^ self new ! !!MyBeeper class methodsFor: 'customize' stamp: 'JB 11/30/2010 16:57' prior: 73269715!setDefault: t1 	default := t1 ! !!MyBeeper class methodsFor: 'customize' stamp: 'JB 11/30/2010 16:57' prior: 73269241!default	default isNil 		ifTrue: [default := self newDefault].	^ default! !!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:57' prior: 70908150!for: t1 	| t2 |	t1 isLiteral 		ifTrue: [^ t1].	t2 := self debugFor: t1 to: StructuralHandleClass.	t2 addBehavior; addState.	t2 becomeHandle.	^ t2! !!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:57' prior: 70905550!recreateClassHandle: t1 with: t2 	| t3 | 	t3 := self debugFor: t1 to: nil.	t3 removeBehavior; addState.	t3 addInstanceVar: t2.	t3 becomeHandle.	t3 compile: self methodClass.	^ t3! !!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:57' prior: 70903365!addInstVarName	^ 'addInstVarName: aString	 				'! !!ClassHandle methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:57' prior: 70898874!initializeHandleWith: t1 to: t2  	| t3 t4 |	receiver := t1.	classLookup := t2.	t3 := t1 class allInstVarNames size.	state := Array new: t3.	state at: 1 put: (t1 instVarAt: 1) copy.	t4 := (t1 instVarAt: 2) copy.	t4 := t4				collect: [:t6 | t6 copy].	state at: 2 put: t4.	3		to: t3		do: [:t5 | state at: t5 put: (t1 instVarAt: t5) copy]! !!ClassHandle methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 16:57' prior: 70872468!initialize	super initialize.	self removeBehavior. 	self addState! !!PropagationTestClass methodsFor: 'basic test method' stamp: 'JB 11/30/2010 16:58' prior: 47421965!temp 	| t1 |	t1 := Object new.	^ t1! !!PropagationTestClass methodsFor: 'send method' stamp: 'JB 11/30/2010 16:58' prior: 47423571!sendToTemp 	| t1 |	t1 := Object new.	^ t1 printString! !!PropagationTestClass methodsFor: 'send method' stamp: 'JB 11/30/2010 16:58' prior: 47423858!sendToSuper 	^ super printString! !!PropagationTestClass methodsFor: 'send method' stamp: 'JB 11/30/2010 16:58' prior: 47423731!sendToSelf	^ self printString ! !!PropagationTestClass methodsFor: 'send method' stamp: 'JB 11/30/2010 16:58' prior: 47472835!sendToInstanceVar	var1 printString. 	^ var1! !!PropagationTestClass methodsFor: 'basic test method' stamp: 'JB 11/30/2010 16:58' prior: 47422755!self	^ self ! !!PropagationTestClass methodsFor: 'basic test method' stamp: 'JB 11/30/2010 16:58' prior: 47424251!instanceVar	^ var1 ! !!PropagationTestClass methodsFor: 'initialize-release' stamp: 'JB 11/30/2010 16:58' prior: 47424697!initialize	var1 := {#a. #b. #c} ! !!PropagationTestClass class methodsFor: 'Expected result' stamp: 'JB 11/30/2010 16:58' prior: 47787860!instanceVar	^ 'instanceVar	^ var1' ! !!PropagationTestClass class methodsFor: 'Expected result' stamp: 'JB 11/30/2010 16:58' prior: 47787748!self	^ 'self	^ self' ! !!PropagationTestClass class methodsFor: 'Expected result' stamp: 'JB 11/30/2010 16:58' prior: 47800086!sendToSelf	^ 'sendToSelf	^ (RewriteMethodWithPropagationHandle for: self rule: [  ]) printString' ! !!PropagationTestClass class methodsFor: 'Expected result' stamp: 'JB 11/30/2010 16:58' prior: 47799875!sendToSuper	^ 'sendToSuper	^ (RewriteMethodWithPropagationHandle superFor: self rule: [  ]) printString' ! !!PropagationTestClass class methodsFor: 'Expected result' stamp: 'JB 11/30/2010 16:58' prior: 47786973!sendToTemp	^ 'sendToTemp	| aTemp |	aTemp := Object new.	^ aTemp printString' ! !!PropagationTestClass class methodsFor: 'Expected result' stamp: 'JB 11/30/2010 16:58' prior: 47786828!temp	^ 'temp	| aTemp |	aTemp := Object new.	^ aTemp' ! !!PropagationTestClass class methodsFor: 'Expected result' stamp: 'JB 11/30/2010 16:58' prior: 33676215!self	^ 'self	^ self'  ! !((PackageInfo named: 'Handles') classes) do:[:each | each compileAll. each class compileAll].!!PropagationTest methodsFor: 'private' stamp: 'JB 11/30/2010 16:59' prior: 47919477!setUp	RewriteMethodWithPropagationHandle resetAll ! !!PropagationTest methodsFor: 'private' stamp: 'JB 11/30/2010 16:59' prior: 47914577!tearDown	PropagationTestClass removeSelector: #testToRemove ! !!PropagationTest methodsFor: 'functional test' stamp: 'JB 11/30/2010 16:59' prior: 33652651!testCreationMethodOnOriginate	"| t1 t2 t3 |	t3 := PropagationTestClass new.	t1 := RewriteMethodWithPropagationHandle 				for: t3				rule: [].	PropagationTestClass compile: 'testToRemove ^false'.	self		should: [t1 testToRemove]		raise: MessageNotUnderstood.	self		shouldnt: [t3 testToRemove]		raise: MessageNotUnderstood"! !!Handle class methodsFor: 'instance creation' stamp: 'JB 11/30/2010 16:59' prior: 47539195!createHandle	^ self new ! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:00' prior: 70831156!testOverload	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) toOverLoad = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:00' prior: 70829551!testMirrorSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorSend = 'mirror' ! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:00' prior: 70830287!testSuperReadSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) superReadSend = 'success' ! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:00' prior: 70828170!testReadAccess	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) readAccess = 'success' ! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:00' prior: 70829986!testMirrorOverLookSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorOverLookSend = 'success' ! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:00' prior: 70828986!testLookupReadSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) lookupReadSend = 'success' ! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:01' prior: 70829759!testMirrorOverSuperSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorOverSuperSend = 'success' ! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:01' prior: 33656808!testUseStateThenStopToUseIt	| handle meta trueObject | 	trueObject := AA new.	handle := (Handle debugFor: trueObject to: A) addBehavior; addState.	meta := MetaHandle for: handle.	handle becomeHandle.	handle var1: 'testHandle'.	self assert: handle var1 = 'testHandle'.	meta removeState.	self deny: handle var1 = 'testHandle'.	self assert: trueObject var1 = handle var1.	meta addState.	self assert: handle var1 = 'testHandle'! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:01' prior: 33657343!testStoreIntoTempReference2	| handle | 	handle := (Handle debugFor: A new to: B) addBehavior; addState; becomeHandle.	self assert: handle isB.	self deny: handle isA! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:01' prior: 33657611!testStoreIntoTempReference	| handle | 	handle := (Handle debugFor: A new to: B) addBehavior; removeState; becomeHandle.	self assert: handle isB.	self deny: handle isA! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:01' prior: 70733028!testStoreIntoInstVarReference	storeIntoInstVar := (Handle debugFor: A new to: B) becomeHandle.	self assert: storeIntoInstVar isA. 	self deny: storeIntoInstVar isB! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:01' prior: 33657881!testRemoveTwice	| handle trueObject |	trueObject := AA new.	handle := (Handle debugFor: trueObject to: A) addBehavior; addState.	handle removeState.	handle removeState. 	self assert: handle configuration = 2.	handle removeBehavior.	handle removeBehavior.	self assert: handle configuration = 0! !!MetaTransactionnal class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:02' prior: 70838090!installState	^ self ! !!TransactionalHandle class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:02' prior: 70847216!debugFor: t1  	| t2 t3 |	t1 isLiteral		ifTrue: [^ t1].	t2 := self createHandle.	t3 := Class new setFormat: t1 class format;				 superclass: t1 class superclass;				 setName: 'TM' , t1 class name;				 methodDict: t1 class methodDict.	t2 initializeHandleWith: t1 to: t3.	^ t2! !!TransactionalManager class methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:02' prior: 70851327!for: t1 	| t2 | 	t2 := self new.	t1		do: [:t3 | t2 addClass: t3].	^ t2! !!TransactionalManager methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:02' prior: 70850691!initialize	classToBrowse := Dictionary new.	objectPool := Dictionary new ! !!TransactionalManager methodsFor: 'execution' stamp: 'JB 11/30/2010 17:02' prior: 70851168!execute: t1 	| t2 | 	t2 := self prepareCode: t1.	t2 doIt! !!TransactionalManager methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:02' prior: 70848987!addObject: t1 	| t2 |	self addClass: t1 class.	t2 := TransactionalHandle debugFor: t1.	objectPool at: t1 put: t2 ! !!TransactionalManager methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:02' prior: 70854101!addClass: t1 	| t2 t3 t4 |	t4 := 'TM_' , t1 name.	t2 := Class new setFormat: t1 format; 				 superclass: t1 superclass;				 setName: t4.	t3 := t1 methodDict copy				collect: [:t5 | 					t5 methodClass: t2.					t5].	t2 methodDict: t3.	classToBrowse at: t1 put: t2! !!TransactionalHandle methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:02' prior: 70837177!initialize	super initialize.	self addState.	self addBehavior ! !!PropagationTestClass methodsFor: 'basic test method' stamp: 'JB 11/30/2010 17:03' prior: 33674988!temp 	| t1 |	t1 := Object new. 	^ t1! !!PropagationTestClass methodsFor: 'send method' stamp: 'JB 11/30/2010 17:03' prior: 33675124!sendToTemp 	| t1 |	t1 := Object new. 	^ t1 printString! !!PropagationTestClass methodsFor: 'send method' stamp: 'JB 11/30/2010 17:03' prior: 33675278!sendToSuper 	^ super printString ! !!PropagationTestClass methodsFor: 'send method' stamp: 'JB 11/30/2010 17:03' prior: 33675409!sendToSelf	^ self printString  ! !!PropagationTestClass methodsFor: 'send method' stamp: 'JB 11/30/2010 17:03' prior: 33675538!sendToInstanceVar	var1 printString. 	^ var1 ! !!PropagationTestClass methodsFor: 'basic test method' stamp: 'JB 11/30/2010 17:03' prior: 33675687!self	^ self  ! !!PropagationTestClass methodsFor: 'basic test method' stamp: 'JB 11/30/2010 17:03' prior: 33675804!instanceVar 	^ var1 ! !!PropagationTestClass methodsFor: 'initialize-release' stamp: 'JB 11/30/2010 17:04' prior: 33675929!initialize	var1 := {#a. #b. #c}  ! !!MyBeeper methodsFor: 'play interface' stamp: 'JB 11/30/2010 17:04' prior: 33672698!play	SoundService default beep ! !!MirrorHandleSubClassTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:04' prior: 70830548!toOverLoad	^ 'NotOverload' ! !!MirrorHandleSubClassTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:04' prior: 70814477!superReadSend	^ super readAccess ! !!MirrorHandleSubClassTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:04' prior: 70814604!lookupReadSend	^ self readAccess ! !!MirrorHandleClassTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:04' prior: 70813778!readAccess	^ 'success' ! !!SubclassOfHelloWorld methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:04' prior: 47417487!upHelloWorld	^ 'upHello in SubClassOfHelloWorld' ! !!HelloWorld methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:04' prior: 47417217!helloWorld	^ 'hello in HelloWorld' ! !!AA methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:04' prior: 70598677!initialize	super initialize.	otherOne := 'toto' ! !!B methodsFor: 'accessing' stamp: 'JB 11/30/2010 17:04' prior: 70724188!toto1	^ 'test' ! !!B methodsFor: 'accessing' stamp: 'JB 11/30/2010 17:04' prior: 33685407!toto1	^ 'test'  ! !!B methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:05' prior: 47074155!testReturn	^ 'success' ! !!B methodsFor: 'accessing' stamp: 'JB 11/30/2010 17:05' prior: 70724106!toto	^ 'test' ! !!B methodsFor: 'accessing' stamp: 'JB 11/30/2010 17:05' prior: 33685705!toto	^ 'tes22t' ! !!B methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:05' prior: 47075601!test2	^ var2 ! !!B methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:05' prior: 47077330!isB	^ true ! !!B methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:05' prior: 47077409!isA	^ false ! !!B methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:05' prior: 47075683!initialize	var2 := 'var2' ! !!B methodsFor: 'accessing' stamp: 'JB 11/30/2010 17:05' prior: 73137760!activeTestWrap	^ self test2 ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:05' prior: 73137254!change	var1 := 'titi' ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:05' prior: 47075893!initialize	var1 := 'var1' ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:05' prior: 47077489!isA	^ true ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 47077745!isB	^ false ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 73215432!self	^ self! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 47086910!send	Object new ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 47074239!testReturn	^ 'failures' ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 67720608!testVar	^ var1 printString ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 33659521!var1: aObject 	var1 := aObject ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 73201541!var1	^ var1 ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 70881910!toto	^ self ! !!A methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:06' prior: 33687159!testVar	^ var1 printString  ! !!MirrorHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:07' prior: 70829435!mirrorSend	^ 'mirror' ! !!MirrorHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:07' prior: 70830660!toOverLoad	^ 'success' ! !!MirrorHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:07' prior: 70823173!mirrorOverSuperSend	^ self superReadSend ! !!MirrorHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 11/30/2010 17:07' prior: 70822841!mirrorOverLookSend	^ self readAccess ! !----STARTUP----an Array(2 December 2010 1:24:45 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!----QUIT/NOSAVE----an Array(2 December 2010 1:25 pm) Handle-Image.TEST.image priorSource: 117504!----STARTUP----an Array(2 December 2010 2:20:53 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!"handles"!----QUIT/NOSAVE----an Array(2 December 2010 2:21:48 pm) Handle-Image.TEST.image priorSource: 117504!----STARTUP----an Array(2 December 2010 3:02:25 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!"handles"!!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 73201541!var1	^ var1! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 73215432!self	^ self! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 47077489!isA	^ true! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 67720608!testVar	^ var1 printString! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 47086910!send	Object new! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 47077745!isB	^ false! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 47075893!initialize	var1 := 'var1'! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 70881910!toto	^ self! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 73137254!change	var1 := 'titi'! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 33659521!var1: aObject 	var1 := aObject! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 47074239!testReturn	^ 'failures'! !!AA methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 70598677!initialize	super initialize.	otherOne := 'toto'! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 33661903!debugMirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior.	^ handle! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 33661134!reflect: aObject	| aBehavior  aMethodDict |	aMethodDict  := aObject class methodDict copy.	aMethodDict		addAll: (self changeStaticHierarchy: self methodDict copy to: aObject class).	aBehavior := Behavior new setFormat: aObject class format;				 superclass: aObject class superclass;				 methodDict: aMethodDict.	aBehavior superclass: aObject class.	^ aBehavior! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 33661615!mirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior; becomeHandle.	^ handle! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 33659816!changeStaticHierarchy: aMethodDict to: aClass aMethodDict		do: [:each | each methodClass: aClass].	^ methodDict! !!B methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:06' prior: 70724188!toto1	^ 'test'! !B removeSelector: #toto1!B removeSelector: #toto!Smalltalk removeClassNamed: #PropagationTestClass!!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33688834!var1	^ var1! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33688932!self	^ self! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689030!isA	^ true! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689127!testVar	^ var1 printString! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689240!send	Object new! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689342!isB	^ false! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689440!initialize	var1 := 'var1'! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689552!toto	^ self! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689650!change	var1 := 'titi'! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689758!var1: aObject 	var1 := aObject! !!A methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689875!testReturn	^ 'failures'! !!AA methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33689986!initialize	super initialize.	otherOne := 'toto'! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33690146!debugMirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior.	^ handle! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33690424!reflect: aObject	| aBehavior  aMethodDict |	aMethodDict  := aObject class methodDict copy.	aMethodDict		addAll: (self changeStaticHierarchy: self methodDict copy to: aObject class).	aBehavior := Behavior new setFormat: aObject class format;				 superclass: aObject class superclass;				 methodDict: aMethodDict.	aBehavior superclass: aObject class.	^ aBehavior! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33690904!mirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior; becomeHandle.	^ handle! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33691191!changeStaticHierarchy: aMethodDict to: aClass aMethodDict		do: [:each | each methodClass: aClass].	^ methodDict! !!B methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47077409!isA	^ false! !!B methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47075601!test2	^ var2! !!B methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47077330!isB	^ true! !!B methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47075683!initialize	var2 := 'var2'! !!B methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73137760!activeTestWrap	^ self test2! !!B methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47074155!testReturn	^ 'success'! !!CapabilityHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73129126!copy: t1 withCapabilities: t2 	| t3 |	t3 := MethodDictionary new.	t2		do: [:t4 | t3 at: t4 put: (t1 class methodDict at: t4) copy].	^ Behavior new setFormat: t1 class format;		 superclass: t1 class superclass;		 methodDict: t3! !!CapabilityHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70767446!debugFor: t1 to: t2 	self shouldNotImplement! !!CapabilityHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73126936!debugFor: t1 with: t2 	| t3 t4 |	t4 := self createHandle.	t3 := t4 copy: t1 withCapabilities: t2.	t4 initializeHandleWith: t1 to: t3.	t4 addBehavior; removeState.	^ t4! !!CapabilityHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70767116!for: t1 with: t2 	| t3 |	t1 isLiteral		ifTrue: [^ t1].	t3 := self debugFor: t1 with: t2.	[t3 becomeHandle]		on: Exception		do: [].	^ t3! !!CapabilityTestClass methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73145001!takeCareAboutSelf	^ self! !!CapabilityTestClass methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73150234!storeAndReturnSelf2	temp2 := self.	^ temp2! !!CapabilityTestClass methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70769703!thisIsPrivateMethod	^ 'You access to a private zone'! !!CapabilityTestClass methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73143306!thisIsPublic	^ 'It is public'! !!CapabilityTestClass methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33659644!storeAndReturnSelf	| aObject |	aObject := self.	^ aObject! !!CapabilityTestClass methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70770083!thisIsPublicInterface	^ self thisIsPrivateMethod! !!ClassHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70898874!initializeHandleWith: t1 to: t2 	| t3 t4 |	receiver := t1.	classLookup := t2.	t3 := t1 class allInstVarNames size.	state := Array new: t3.	state at: 1 put: (t1 instVarAt: 1) copy.	t4 := (t1 instVarAt: 2) copy.	t4 := t4				collect: [:t6 | t6 copy].	state at: 2 put: t4.	3		to: t3		do: [:t5 | state at: t5 put: (t1 instVarAt: t5) copy]! !!ClassHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70872468!initialize	super initialize.	self removeBehavior.	self addState! !!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70903365!addInstVarName	^ 'addInstVarName: aString					'! !!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70905550!recreateClassHandle: t1 with: t2 	| t3 |	t3 := self debugFor: t1 to: nil.	t3 removeBehavior; addState.	t3 addInstanceVar: t2.	t3 becomeHandle.	t3 compile: self methodClass.	^ t3! !!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70908150!for: t1 	| t2 |	t1 isLiteral		ifTrue: [^ t1].	t2 := self debugFor: t1 to: StructuralHandleClass.	t2 addBehavior; addState.	t2 becomeHandle.	^ t2! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70893193!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33648733!expectedFailures	^#(#testCreationMethodOnHandle).! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70896549!testClassVarNames	self		assert: ((ClassHandle for: A) classVarNames includes: #Coucou).	self assert: (ClassHandle for: A) classVarNames = (ClassHandle for: A) class classVarNames! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70897211!testRenaming	^ self! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70896894!testCompileAll	self		shouldnt: [(ClassHandle for: A) compileAll]		raise: Error! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33648971!testAddInstVarName	| classHandle |	classHandle := ClassHandle for: A.	classHandle addInstVarName: 'x'.	self assert: classHandle instVarNames = #('x' ).	classHandle addInstVarName: 'y'.	self assert: classHandle instVarNames = #('x' 'y' )! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33649653!deleteClass	| mustRemove |	mustRemove := Smalltalk globals				at: className				ifAbsent: [^ self].	mustRemove removeFromChanges; removeFromSystemUnlogged! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33649399!deleteRenamedClass	| mustRemove |	mustRemove := Smalltalk globals				at: renamedName				ifAbsent: [^ self].	mustRemove removeFromChanges; removeFromSystemUnlogged! !!ClassHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33648277!testCreationMethodOnHandle	"| t1 t2 t3 t4 |	t3 := PropagationTestClass new.	t1 := RewriteMethodWithPropagationHandle				debugFor: t3				rule: [].	t4 := t1 classLookup.	t1 becomeHandle.	t4 compile: 'testToRemove ^false'.	self		shouldnt: [t1 testToRemove]		raise: MessageNotUnderstood.	self		should: [t3 testToRemove]		raise: MessageNotUnderstood"! !!ClassJB methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70863829!addClassVarName: t1 	Transcript show: 'Handle Rule';		 cr.	^ super addClassVarName: t1! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33644283!initializeHandleWith: aObject to: aClass 	| size |	receiver := aObject.	classLookup := aClass.	size := aObject class allInstVarNames size.	state := Array new: size.	1		to: size		do: [:index | state				at: index				put: (aObject instVarAt: index)]! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33644149!classLookup: aClass 	classLookup := aClass! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70729522!configuration	^ configuration! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33644621!receiver: aObject 	receiver := aObject! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73130524!removeSelfWrapping	configuration := configuration bitAnd: 3! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47069016!receiver	^ receiver! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47054757!classLookup	^ classLookup! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70873038!initialize	classLookup := nil.	configuration := 0.	self removeBehavior.	self removeState! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70806690!becomeHandle	<primitive: 575>	^ self primitiveFailed! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73130801!removeState	configuration := configuration bitAnd: 6! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70872619!addBehavior	self classLookup		ifNil: [^ Error signal: 'classLookup  isNil you want to crash the VM ?'].	configuration := configuration bitOr: 2! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73130387!addSelfWrapping	configuration := configuration bitOr: 4! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47055142!isHandler	^ true! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70730174!addState	configuration := configuration bitOr: 1! !!Handle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73130665!removeBehavior	configuration := configuration bitAnd: 5! !!Handle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33643493!debugFor: aObject to: aClass 	| handle |	handle := self createHandle.	handle initializeHandleWith: aObject to: aClass.	^ handle! !!Handle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33643932!for: aObject to: aClass 	| handle |	handle := self debugFor: aObject to: aClass.	handle addBehavior.	handle becomeHandle.	^ handle! !!Handle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33610312!debugFor: aObject	| handle |	handle := self createHandle.	handle receiver: aObject.	handle addState.	^ handle! !!Handle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33643711!for: aObject 	| handle |	handle := self debugFor: aObject to: nil.	handle removeBehavior; addState.	handle becomeHandle.	^ handle! !!Handle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47539195!createHandle	^ self new! !!HandleBehaviorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33649961!testInterceptMessage	| handle |	handle := Handle debugFor: A new to: B.	handle addBehavior; removeState; becomeHandle.	self assert: handle testReturn = 'success'! !!HandleBehaviorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33650230!testdontChangeOriginalObject	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeState; becomeHandle.	self assert: trueObject isA.	self deny: trueObject isB.	self assert: handle isB.	self deny: handle isA! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73148255!testCapabilitiesSelfTest	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#takeCareAboutSelf )) takeCareAboutSelf]		raise: MessageNotUnderstood.	self		should: [(CapabilityHandle for: CapabilityTestClass new with: #(#takeCareAboutSelf )) takeCareAboutSelf thisIsPrivateMethod]		raise: MessageNotUnderstood! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73140922!testCapabilitiesPrivateAccess	self		should: [(CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublicInterface )) thisIsPrivateMethod]		raise: MessageNotUnderstood! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73142880!testCapabilitiesPrivateThroughtPublicAccess	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublicInterface )) thisIsPublicInterface]		raise: MessageNotUnderstood.	self assert: (CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublicInterface )) thisIsPublicInterface = 'You access to a private zone'! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73151389!testCapabilitiesStoreAndReturnSelfInstance	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#storeAndReturnSelf2 )) storeAndReturnSelf2]		raise: MessageNotUnderstood.	self		should: [(CapabilityHandle for: CapabilityTestClass new with: #(#storeAndReturnSelf2 )) storeAndReturnSelf2 thisIsPrivateMethod]		raise: MessageNotUnderstood! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73143853!testCapabilitiesPublicAccess	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublic )) thisIsPublic]		raise: MessageNotUnderstood.	self assert: (CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublic )) thisIsPublic = 'It is public'! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73149577!testCapabilitiesStoreAndReturnSelf	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#storeAndReturnSelf )) storeAndReturnSelf]		raise: MessageNotUnderstood.	self		should: [(CapabilityHandle for: CapabilityTestClass new with: #(#storeAndReturnSelf )) storeAndReturnSelf thisIsPrivateMethod]		raise: MessageNotUnderstood! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33650608!testIdentityObject1	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33652070!testIdentityObject3	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; addState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33650908!testIdentityObject2	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33651770!testIdentityObject4	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33657343!testStoreIntoTempReference2	| handle |	handle := (Handle debugFor: A new to: B) addBehavior; addState; becomeHandle.	self assert: handle isB.	self deny: handle isA! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70733028!testStoreIntoInstVarReference	storeIntoInstVar := (Handle debugFor: A new to: B) becomeHandle.	self assert: storeIntoInstVar isA.	self deny: storeIntoInstVar isB! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33656808!testUseStateThenStopToUseIt	| handle meta trueObject |	trueObject := AA new.	handle := (Handle debugFor: trueObject to: A) addBehavior; addState.	meta := MetaHandle for: handle.	handle becomeHandle.	handle var1: 'testHandle'.	self assert: handle var1 = 'testHandle'.	meta removeState.	self deny: handle var1 = 'testHandle'.	self assert: trueObject var1 = handle var1.	meta addState.	self assert: handle var1 = 'testHandle'! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33657611!testStoreIntoTempReference	| handle |	handle := (Handle debugFor: A new to: B) addBehavior; removeState; becomeHandle.	self assert: handle isB.	self deny: handle isA! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33657881!testRemoveTwice	| handle trueObject |	trueObject := AA new.	handle := (Handle debugFor: trueObject to: A) addBehavior; addState.	handle removeState.	handle removeState.	self assert: handle configuration = 2.	handle removeBehavior.	handle removeBehavior.	self assert: handle configuration = 0! !!HandleSelfWrappingTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33658289!testDesactiveSelfWrap	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeSelfWrapping; becomeHandle.	self		should: [handle activeTestWrap]		raise: MessageNotUnderstood! !!HandleSelfWrappingTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33658634!testActiveSelfWrap	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; addSelfWrapping; becomeHandle.	self		shouldnt: [handle activeTestWrap]		raise: MessageNotUnderstood! !!HandleStateTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33658968!testChangingStateOrigine	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; addState; becomeHandle.	trueObject var1: 'test'.	self deny: handle var1 = 'test'! !!HelloWorld methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47417217!helloWorld	^ 'hello in HelloWorld'! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33582031!handleThirdStep	^ Lesson title: 'handle ' lesson: '"The other skill of the handle is to create indirection on StateThat mean you can create a Handle, which keep this own state.try"|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33586048!handleSecondStep	^ Lesson title: 'handle ' lesson: '"The API for using handle is very simple.""a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on ''a'' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33585346!handleFirstStep	^ Lesson title: 'handle first indirection' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33557309!handlePreTest	^ Lesson title: 'handle support?' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachineForHandle." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zipAndTestYourImage :"HowDoUseHandle testImageForHandle."If this test fails, you can load the code by loading the configurationOfHandle"ProfStef next.'! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33638263!handleMeta	^ Lesson title: 'Smell like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1. "''var1''"metaH addState.handle var1: ''state save''.handle var1.  "''state save''"metaH removeStatehandle var1."  ''var1''"metaH addState.handle var1.  "''state save''""Be care to not lost the Reference MetaHandle or you can not changing the handle anymore !!!!""It''s enough for the core of Handle"ProfStef next.'! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33620732!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Object.ProfStef next.'! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33556627!handleWhatIsIt	^ Lesson title: 'handle support?' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachine." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zip" AndTestYourImage :"HowDoUseHandle testImage."If this test fails, you can load the code by loading the configurationOfHandle""ProfStef next.'! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33629359!tutorial	^ #(#handlePreTest handlePrinciple handleFirstStep handleSecondStep handleThirdStep handleFourStep handleMeta)! !!HowDoUseHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33563383!handlePrinciple	^ Lesson title: 'handle principle' lesson: '"As we say previously Handle is a special object that allow you to create indirection on Behavior or on State.This tutorial, is separate in 3 Step,	- Learn the Core model of The Handle and How to use it.	- Learn how use the different application created for the handle.	- And learn how extend Handles to create your specifique indirection on Handle.the core Model of Handle is pretty simple, is just composed of 2 class,Handle : Handle is a object know by the VM, it''s represent a indirection, do on a object, such a transparent proxy.MetaHandle : MetaHandle is Handle which able to configure the Handle. We need this object because once we activate a handle, is become a unreachable object. Invisible From the image part."ProfStef next.'! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33641286!testVirtualMachineForHandle	[(Handle new) becomeHandle] on: Error do: [^false].	^true.! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33641480!testImageForHandle	^[(SmalltalkImage current specialObjectsArray at: 51) == Handle] on: Error do:[false]! !!MetaHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73175443!isMeta	^ true! !!MetaHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70918049!initialize	super initialize! !!MetaHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33644892!for: aHandle	^ self for: aHandle  to: self! !!MetaTransactionnal class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70838090!installState	^ self! !!MetaWatcher methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73169724!isMeta	^ true! !!MetaWatcher methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73177133!unWatch	self receiver become: self! !!MirrorHandleClassTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70813778!readAccess	^ 'success'! !!MirrorHandleSubClassTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70814477!superReadSend	^ super readAccess! !!MirrorHandleSubClassTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70830548!toOverLoad	^ 'NotOverload'! !!MirrorHandleSubClassTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70814604!lookupReadSend	^ self readAccess! !!MirrorHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70822841!mirrorOverLookSend	^ self readAccess! !!MirrorHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70829435!mirrorSend	^ 'mirror'! !!MirrorHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70823173!mirrorOverSuperSend	^ self superReadSend! !!MirrorHandleTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70830660!toOverLoad	^ 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70831156!testOverload	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) toOverLoad = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70829759!testMirrorOverSuperSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorOverSuperSend = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70828986!testLookupReadSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) lookupReadSend = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70828170!testReadAccess	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) readAccess = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70829986!testMirrorOverLookSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorOverLookSend = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70830287!testSuperReadSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) superReadSend = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70829551!testMirrorSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorSend = 'mirror'! !!MyBeeper methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73268055!play	SoundService default beep! !!MyBeeper class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73269052!clearDefault	default := nil! !!MyBeeper class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73269464!newDefault	^ self new! !!MyBeeper class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73269715!setDefault: t1 	default := t1! !!MyBeeper class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73268306!beep	self default		ifNil: [self beepPrimitive]		ifNotNil: [self default play]! !!MyBeeper class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73269241!default	default isNil		ifTrue: [default := self newDefault].	^ default! !!MyBeeper class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73268710!beepPrimitive	SoundSettings soundEnabled		ifTrue: [self primitiveBeep]! !!ObjectHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70880740!debugFor: t1 to: t2 	| t3 t4 t5 |	t3 := self createHandle.	t4 := ClassHandle for: t2.	t3 initializeHandleWith: t1 to: t4.	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72901783!primURLRequest: t1 semaIndex: t2 	<primitive: 'primitivePluginRequestURLStream'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73086248!basicNextPut: t1 	<primitive: 66>	(collection class == ByteString			and: [t1 isCharacter					and: [t1 isOctetCharacter not]])		ifTrue: [collection := WideString from: collection.			^ self nextPut: t1].	position >= writeLimit		ifTrue: [^ self pastEndPut: t1].	position := position + 1.	^ collection at: position put: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72886544!primSetClipRect: t1 	<primitive: 'primitiveSetClipRect' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72980769!newMethod: t1 header: t2 	<primitive: 79>	(t1 isInteger			and: [t2 isInteger					and: [t1 >= 0]])		ifTrue: [OutOfMemory signal.			^ self newMethod: t1 header: t2].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72834219!bitXor: t1 	<primitive: 16>	^ super bitXor: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73001033!primGetIndMenuItemWithCommandID: t1 commandID: t2 	<primitive: 'primitiveGetIndMenuItemWithCommandID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72949589!primSocket: t1 setOption: t2 value: t3 	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72965381!nextObjectAfter: t1 	<primitive: 139>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73041120!hasSocketAccess	<primitive: 'primitiveHasSocketAccess' module: 'SocketPlugin'>	^ true! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72950322!primSocketLocalAddressSize: t1 	<primitive: 'primitiveSocketLocalAddressSize' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72874328!putInteger32: t1 at: t2 	| t3 |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	t3 := t1.	t3 < 0		ifTrue: [t3 := 1073741824 - t3].	self		at: t2 + 3		put: (Character value: t3 \\ 256).	self		at: t2 + 2		put: (Character value: (t3 bitShift: -8)					\\ 256).	self		at: t2 + 1		put: (Character value: (t3 bitShift: -16)					\\ 256).	self		at: t2		put: (Character value: (t3 bitShift: -24)					\\ 256)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72918482!primRetryShowRectLeft: t1 right: t2 top: t3 bottom: t4 	<primitive: 127>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72888651!primNextActiveEdgeEntryInto: t1 	<primitive: 'primitiveNextActiveEdgeEntry' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72913580!primDeleteFileNamed: t1 	<primitive: 'primitiveFileDelete' module: 'FilePlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72996982!primPortDirectionalityOf: t1 	<primitive: 'primitiveMIDIGetPortDirectionality' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72950536!primSocketReceiveDataAvailable: t1 	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73044976!setGCBiasToGrow: t1 	<primitive: 'primitiveSetGCBiasToGrow'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73073120!primMIDIClosePort: t1 	<primitive: 'primitiveMIDIClosePort' module: 'MIDIPlugin'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73003215!primAppendMenuItemText: t1 data: t2 	<primitive: 'primitiveAppendMenuItemText' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72890102!primSetDepth: t1 	<primitive: 'primitiveSetDepth' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73000043!primSoundAvailableBytes	<primitive: 'primitiveSoundAvailableSpace' module: 'SoundPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73016961!primRenderGlyphIntoForm: t1 pixelMode: t2 	<primitive: 'primitiveRenderGlyphIntoFormWithRenderMode' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73074735!privateEncodeMono: t1 	| t2 t3 t4 t5 t6 t7 t8 |	<primitive: 'primitiveEncodeMono' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	t2 := stepSizeTable at: 1.	1		to: t1		do: [:t9 | (t9 bitAnd: frameSizeMask)					= 1				ifTrue: [predicted := samples at: (sampleIndex := sampleIndex + 1).					(t8 := predicted) < 0						ifTrue: [t8 := t8 + 65536].					self nextBits: 16 put: t8.					t9 < t1						ifTrue: [index := self										indexForDeltaFrom: predicted										to: (samples at: sampleIndex + 1)].					self nextBits: 6 put: index]				ifFalse: [t3 := 0.					t4 := (samples at: (sampleIndex := sampleIndex + 1))								- predicted.					t4 < 0						ifTrue: [t3 := deltaSignMask.							t4 := 0 - t4].					t5 := 0.					t6 := 0.					t7 := deltaValueHighBit.					[t7 > 0]						whileTrue: [t4 >= t2								ifTrue: [t5 := t5 + t7.									t6 := t6 + t2.									t4 := t4 - t2].							t2 := t2 bitShift: -1.							t7 := t7 bitShift: -1].					t6 := t6 + t2.					t3 > 0						ifTrue: [predicted := predicted - t6]						ifFalse: [predicted := predicted + t6].					predicted > 32767						ifTrue: [predicted := 32767]						ifFalse: [predicted < -32768								ifTrue: [predicted := -32768]].					index := index								+ (indexTable at: t5 + 1).					index < 0						ifTrue: [index := 0]						ifFalse: [index > 88								ifTrue: [index := 88]].					t2 := stepSizeTable at: index + 1.					self						nextBits: bitsPerSample						put: (t3 bitOr: t5)]].	bitPosition > 0		ifTrue: [encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73038714!primProcessBuffer: t1 withState: t2 	<primitive: 'primitiveProcessBufferWithState' module: 'MD5Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72805731!exp	| t1 t2 t3 t4 t5 |	<primitive: 59>	self < 0.0		ifTrue: [^ self negated exp reciprocal].	self = 0.0		ifTrue: [^ 1].	self abs > MaxValLn		ifTrue: [self error: 'exp overflow'].	t1 := E raisedToInteger: self truncated.	t2 := self fractionPart.	t2 = 0.0		ifTrue: [^ t1].	t3 := 1.0 + t2.	t4 := t2 * t2 / 2.0.	t5 := 2.0.	[t4 > Epsilon]		whileTrue: [t3 := t3 + t4.			t5 := t5 + 1.0.			t4 := t4 * t2 / t5].	t3 := t3 + t4.	^ t1 * t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72939766!localBounds: t1 toGlobal: t2 	<primitive: 'primitiveTransformRectInto' module: 'Matrix2x3Plugin'>	^ super localBoundsToGlobal: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73030533!value: t1 value: t2 value: t3 value: t4 	| t5 t6 |	<primitive: 205>	numArgs ~= 4		ifTrue: [self numArgsError: 4].	t5 := self asContextWithSender: thisContext sender.	t6 := self numCopiedValues.	t5 stackp: t6 + 4.	t5 at: 1 put: t1.	t5 at: 2 put: t2.	t5 at: 3 put: t3.	t5 at: 4 put: t4.	1		to: t6		do: [:t7 | t5				at: t7 + 4				put: (self at: t7)].	thisContext privSender: t5! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72840725!normalize	| t1 t2 t3 t4 t5 |	<primitive: 'primNormalizeNegative' module: 'LargeIntegers'>	t3 := t4 := self digitLength.	[t3 = 0		ifTrue: [^ 0].	(self digitAt: t3)		= 0]		whileTrue: [t3 := t3 - 1].	t1 := 4.	t3 <= t1		ifTrue: [t5 := SmallInteger minVal.			(t3 < t1					or: [(self digitAt: t1)							< t5 lastDigit])				ifTrue: [t2 := 0.					t3						to: 1						by: -1						do: [:t6 | t2 := t2 * 256										- (self digitAt: t6)].					^ t2].			1				to: t1				do: [:t7 | (self digitAt: t7)							= (t5 digitAt: t7)						ifFalse: [t3 < t4								ifTrue: [^ self growto: t3].							^ self]].			^ t5].	t3 < t4		ifTrue: [^ self growto: t3]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73101992!primClose: t1 	<primitive: 'primitiveFileClose' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73022260!primCopyToExternalMemory: t1 	<primitive: 'primitiveCopyToExternalMemory' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72791408!primMIDIParameterSet: t1 to: t2 	<primitive: 'primitiveMIDIParameterGetOrSet' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72848187!primWriteResult: t1 	<primitive: 'primitiveAsyncFileWriteResult' module: 'AsynchFilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72775230!basicIdentityHash	<primitive: 75>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72964614!lExternalCall2	<primitive: 'prim2' module: 'LPCCT'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72976904!primNameResolverError	<primitive: 'primitiveResolverError' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72870422!pvtAt: t1 	<primitive: 143>	t1 isInteger		ifTrue: [self errorSubscriptBounds: t1].	t1 isNumber		ifTrue: [^ self at: t1 truncated].	self errorNonIntegerIndex! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72891383!primGetOffset	<primitive: 'primitiveGetOffset' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72903944!primURLRequestDestroy: t1 	<primitive: 'primitivePluginDestroyRequest'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72951224!primSocket: t1 remoteAddressResult: t2 	<primitive: 'primitiveSocketRemoteAddressResult' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73004070!primGetMenuItemKeyGlyph: t1 item: t2 	<primitive: 'primitiveGetMenuItemKeyGlyph' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73004508!primGetItemStyle: t1 item: t2 	<primitive: 'primitiveGetItemStyle' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72852891!primDivScalar: t1 and: t2 into: t3 	<primitive: 'primitiveDivScalar' module: 'KedamaPlugin'>	1		to: t1 size		do: [:t4 | t3 at: t4 put: (t1 at: t4)					/ t2].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72892382!primFinishedProcessing	<primitive: 'primitiveFinishedProcessing' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72978259!primAbortLookup	<primitive: 'primitiveResolverAbortLookup' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72935730!tempAt: t1 	<primitive: 210>	^ self at: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72780001!perform: t1 with: t2 	<primitive: 83>	^ self		perform: t1		withArguments: (Array with: t2)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73004727!primSetMenuItemTextEncoding: t1 item: t2 inScriptID: t3 	<primitive: 'primitiveSetMenuItemTextEncoding' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73015184!primitiveWindowClose: t1 	<primitive: 'primitiveCloseHostWindow' module: 'HostWindowPlugin'>	^ self windowProxyError: 'close'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73083459!primGetActualRecordingSampleRate	<primitive: 'primitiveSoundGetRecordingSampleRate' module: 'SoundPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73033190!newProcessWith: t1 	<primitive: 19>	^ Process forContext: [self valueWithArguments: t1.		Processor terminateActive] asContext priority: Processor activePriority! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72807152!fractionPart	<primitive: 52>	^ self - self truncated asFloat! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72850337!primMulScalar: t1 and: t2 into: t3 	<primitive: 'primitiveMulScalar' module: 'KedamaPlugin'>	1		to: t1 size		do: [:t4 | t3 at: t4 put: (t1 at: t4)					* t2].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72833282!digitAt: t1 put: t2 	<primitive: 61>	^ super at: t1 put: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73102525!primGetPosition: t1 	<primitive: 'primitiveFileGetPosition' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72993318!setXWinEncToLocale	<primitive: 'primSetXWinEncToLocale' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73018971!primSetTransform: t1 delta: t2 	<primitive: 'primitiveSetTransform' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72910757!primitiveResume	<primitive: 87>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72834598!+ t1 	<primitive: 21>	^ super + t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72967811!primTimezone	<primitive: 'primitiveTimezoneOffset' module: 'LocalePlugin'>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73021066!primNewFaceFromExternalMemory: t1 size: t2 index: t3 	<primitive: 'primitiveNewMemoryFaceFromExternalMemoryAndIndex' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73006136!primGetMenuItemFontID: t1 item: t2 	<primitive: 'primitiveGetMenuItemFontID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72869037!sum	<primitive: 'primitiveSum' module: 'FloatArrayPlugin'>	^ super sum! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73020028!primGetCharMapsInto: t1 	<primitive: 'primitiveGetFaceCharMapsIntoArray' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72961795!cExternalCallWithoutModule	<primitive: 'primGetModuleName'>	^ 'Hello World!!'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72923364!basicAt: t1 	<primitive: 210>	t1 isInteger		ifTrue: [self errorSubscriptBounds: t1].	t1 isNumber		ifTrue: [^ self at: t1 asInteger].	self errorNonIntegerIndex! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73102766!primOpen: t1 writable: t2 	<primitive: 'primitiveFileOpen' module: 'FilePlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72896202!primAddExternalEdge: t1 initialX: t2 initialY: t3 initialZ: t4 leftFillIndex: t5 rightFillIndex: t6 	<primitive: 'primitiveRegisterExternalEdge' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddExternalEdge: t1				initialX: t2				initialY: t3				initialZ: t4				leftFillIndex: t5				rightFillIndex: t6].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72776963!tryNamedPrimitive: t1 with: t2 with: t3 with: t4 with: t5 with: t6 	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72873059!primMakeUUID	<primitive: 'primitiveMakeUUID' module: 'UUIDPlugin'>	UUIDGenerator default generateBytes: self forVersion: 4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72846791!primReadStart: t1 fPosition: t2 count: t3 	<primitive: 'primitiveAsyncFileReadStart' module: 'AsynchFilePlugin'>	self error: 'READ THE COMMENT FOR THIS METHOD.'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73085790!atEnd	<primitive: 67>	^ position = streamSize! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72963850!lDisabledExternalCallWithoutModule	<primitive: 'primGetModuleName'>	^ 'Hello World!!'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73006846!primInsertFontResMenu: t1 afterItem: t2 scriptFilter: t3 	<primitive: 'primitiveInsertFontResMenu' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73046720!imageFormatVersion	<primitive: 'primitiveImageFormatVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveImageFormatVersion' translated.	^ ''! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73035227!on: t1 do: t2 	| t3 |	<primitive: 199>	t3 := true.	^ self value! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73103716!primWrite: t1 from: t2 startingAt: t3 count: t4 	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>	self isClosed		ifTrue: [^ self error: 'File is closed'].	self error: 'File write failed'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72953188!primSocketAbortConnection: t1 	<primitive: 'primitiveSocketAbortConnection' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73007576!primInsertMenuItem: t1 itemString: t2 afterItem: t3 	<primitive: 'primitiveInsertMenuItem' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72989630!listFont: t1 	<primitive: 'primitiveListFont' module: 'FontPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73014125!primitiveUpdateHostWindow: t1 bitmap: t2 width: t3 height: t4 depth: t5 left: t6 right: t7 top: t8 bottom: t9 	<primitive: 'primitiveShowHostWindowRect' module: 'HostWindowPlugin'>	^ self windowProxyError: 'update'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72913853!primSetMacFileNamed: t1 type: t2 creator: t3 	<primitive: 'primitiveDirectorySetMacTypeAndCreator' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72791635!primMIDIGetPortCount	<primitive: 'primitiveMIDIGetPortCount' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72845676!primJPEGCompressStructSize	<primitive: 'primJPEGCompressStructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72851969!primAddArray: t1 and: t2 into: t3 	<primitive: 'primitiveAddArrays' module: 'KedamaPlugin'>	1		to: t1 size		do: [:t4 | t3 at: t4 put: (t1 at: t4)					+ (t2 at: t4)].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73008082!primInsertMenu: t1 beforeID: t2 	<primitive: 'primitiveInsertMenu' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73014865!primitiveWindowSize: t1 x: t2 y: t3 	<primitive: 'primitiveHostWindowSizeSet' module: 'HostWindowPlugin'>	^ self windowProxyError: 'set size'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73047340!platformSourceVersion	<primitive: 'primitivePlatformSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitivePlatformSourceVersion' translated.	^ ''! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73022591!primLoadSizesFrom: t1 	<primitive: 'primitiveLoadOutlineSizesFromFace' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72944367!primitiveFontEmbeddingFlags: t1 	<primitive: 'primitiveFontEmbeddingFlags' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72965837!someInstanceOf: t1 	<primitive: 77>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73016378!primRenderGlyphIntoForm: t1 	<primitive: 'primitiveRenderGlyphIntoForm' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72887361!primAddRectFrom: t1 to: t2 fillIndex: t3 borderWidth: t4 borderColor: t5 	<primitive: 'primitiveAddRect' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddRectFrom: t1				to: t2				fillIndex: t3				borderWidth: t4				borderColor: t5].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72887787!primGetBezierStats: t1 	<primitive: 'primitiveGetBezierStats' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73047898!primBytesLeft	<primitive: 112>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73048278!forceTenure	<primitive: 'primitiveForceTenure'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72882631!pvtAt: t1 put: t2 	<primitive: 61>	t1 isInteger		ifTrue: [self errorSubscriptBounds: t1]		ifFalse: [self errorNonIntegerIndex]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73077284!privateDecodeStereo: t1 	| t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 |	<primitive: 'primitiveDecodeStereo' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	self var: #rightSamples declareC: 'short int *rightSamples'.	self var: #predicted declareC: 'short int *predicted'.	self var: #index declareC: 'short int *index'.	t2 := predicted at: 1.	t3 := predicted at: 2.	t4 := index at: 1.	t5 := index at: 2.	1		to: t1		do: [:t13 | (t13 bitAnd: frameSizeMask)					= 1				ifTrue: [t2 := self nextBits: 16.					t4 := self nextBits: 6.					t3 := self nextBits: 16.					t5 := self nextBits: 6.					t2 > 32767						ifTrue: [t2 := t2 - 65536].					t3 > 32767						ifTrue: [t3 := t3 - 65536].					samples at: (sampleIndex := sampleIndex + 1) put: t2.					rightSamples at: sampleIndex put: t3]				ifFalse: [t6 := self nextBits: bitsPerSample.					t7 := self nextBits: bitsPerSample.					t8 := stepSizeTable at: t4 + 1.					t9 := stepSizeTable at: t5 + 1.					t10 := t11 := 0.					t12 := deltaValueHighBit.					[t12 > 0]						whileTrue: [(t6 bitAnd: t12)									> 0								ifTrue: [t10 := t10 + t8].							(t7 bitAnd: t12)									> 0								ifTrue: [t11 := t11 + t9].							t8 := t8 bitShift: -1.							t9 := t9 bitShift: -1.							t12 := t12 bitShift: -1].					t10 := t10 + t8.					t11 := t11 + t9.					(t6 bitAnd: deltaSignMask)							> 0						ifTrue: [t2 := t2 - t10]						ifFalse: [t2 := t2 + t10].					(t7 bitAnd: deltaSignMask)							> 0						ifTrue: [t3 := t3 - t11]						ifFalse: [t3 := t3 + t11].					t2 > 32767						ifTrue: [t2 := 32767]						ifFalse: [t2 < -32768								ifTrue: [t2 := -32768]].					t3 > 32767						ifTrue: [t3 := 32767]						ifFalse: [t3 < -32768								ifTrue: [t3 := -32768]].					t4 := t4								+ (indexTable at: (t6 bitAnd: deltaValueMask)											+ 1).					t4 < 0						ifTrue: [t4 := 0]						ifFalse: [t4 > 88								ifTrue: [t4 := 88]].					t5 := t5								+ (indexTable at: (t7 bitAnd: deltaValueMask)											+ 1).					t5 < 0						ifTrue: [t5 := 0]						ifFalse: [t5 > 88								ifTrue: [t5 := 88]].					samples at: (sampleIndex := sampleIndex + 1) put: t2.					rightSamples at: sampleIndex put: t3]].	predicted at: 1 put: t2.	predicted at: 2 put: t3.	index at: 1 put: t4.	index at: 2 put: t5! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73016581!primSetPixelWidth: t1 height: t2 	<primitive: 'primitiveSetPixelSizes' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73009203!primGetMenuBar	<primitive: 'primitiveGetMenuBar' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72782903!perform: t1 with: t2 with: t3 with: t4 	<primitive: 83>	^ self		perform: t1		withArguments: (Array				with: t2				with: t3				with: t4)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72943174!primitiveCreateFont: t1 size: t2 emphasis: t3 	<primitive: 'primitiveCreateFont' module: 'FontPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72889731!primFlushNeeded: t1 	<primitive: 'primitiveNeedsFlushPut' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72803368!arcTan	| t1 t2 t3 t4 t5 |	<primitive: 57>	self < 0.0		ifTrue: [^ 0.0 - (0.0 - self) arcTan].	t1 := self * Halfpi / (self + 1.0).	t2 := Halfpi * Epsilon.	t3 := t1.	[t3 * t3 > t2]		whileTrue: [t4 := t1 sin.			t5 := t1 cos.			t3 := t4 * t5 - (self * t5 * t5).			t1 := t1 - t3].	^ t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72938557!globalBounds: t1 toLocal: t2 	<primitive: 'primitiveInvertRectInto' module: 'Matrix2x3Plugin'>	^ super globalBoundsToLocal: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73108449!privateSendBlock: t1 with: t2 with: t3 with: t4 	| t5 t6 t7 t8 t9 |	<primitive: 'primitiveZipSendBlock' module: 'ZipPlugin'>	t9 := 0.	[t5 := t1 next.	t6 := t2 next.	t5 == nil]		whileFalse: [t6 = 0				ifTrue: [t9 := t9 + 1.					self						nextBits: (t3 bitLengthAt: t5)						put: (t3 codeAt: t5)]				ifFalse: [t9 := t9 + t5 + MinMatch.					t7 := MatchLengthCodes at: t5 + 1.					self						nextBits: (t3 bitLengthAt: t7)						put: (t3 codeAt: t7).					t8 := ExtraLengthBits at: t7 - NumLiterals.					t8 = 0						ifFalse: [t5 := t5										- (BaseLength at: t7 - NumLiterals).							self nextBits: t8 put: t5].					t6 := t6 - 1.					t6 < 256						ifTrue: [t7 := DistanceCodes at: t6 + 1]						ifFalse: [t7 := DistanceCodes at: 257											+ (t6 bitShift: -7)].					self						nextBits: (t4 bitLengthAt: t7)						put: (t4 codeAt: t7).					t8 := ExtraDistanceBits at: t7 + 1.					t8 = 0						ifFalse: [t6 := t6										- (BaseDistance at: t7 + 1).							self nextBits: t8 put: t6]]].	^ t9! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73010299!primSetMenuItemCommandID: t1 item: t2 menuCommand: t3 	<primitive: 'primitiveSetMenuItemCommandID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72859478!compress: t1 toByteArray: t2 	| t3 t4 t5 t6 t7 t8 t9 |	<primitive: 'primitiveCompressToByteArray' module: 'MiscPrimitivePlugin'>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	t3 := t1 size.	t9 := self				encodeInt: t3				in: t2				at: 1.	t4 := 1.	[t4 <= t3]		whileTrue: [t5 := t1 at: t4.			t7 := t5 bitAnd: 255.			t8 := (t5 >> 8 bitAnd: 255)							= t7						and: [(t5 >> 16 bitAnd: 255)									= t7								and: [(t5 >> 24 bitAnd: 255)										= t7]].			t6 := t4.			[t6 < t3				and: [t5						= (t1 at: t6 + 1)]]				whileTrue: [t6 := t6 + 1].			t6 > t4				ifTrue: [t8						ifTrue: [t9 := self										encodeInt: t6 - t4 + 1 * 4 + 1										in: t2										at: t9.							t2 at: t9 put: t7.							t9 := t9 + 1]						ifFalse: [t9 := self										encodeInt: t6 - t4 + 1 * 4 + 2										in: t2										at: t9.							t9 := self										encodeBytesOf: t5										in: t2										at: t9].					t4 := t6 + 1]				ifFalse: [t8						ifTrue: [t9 := self										encodeInt: 1 * 4 + 1										in: t2										at: t9.							t2 at: t9 put: t7.							t9 := t9 + 1.							t4 := t4 + 1]						ifFalse: [[t6 < t3								and: [(t1 at: t6)										~= (t1 at: t6 + 1)]]								whileTrue: [t6 := t6 + 1].							t6 = t3								ifTrue: [t6 := t6 + 1].							t9 := self										encodeInt: t6 - t4 * 4 + 3										in: t2										at: t9.							t4								to: t6 - 1								do: [:t10 | t9 := self												encodeBytesOf: (t1 at: t10)												in: t2												at: t9].							t4 := t6]]].	^ t9 - 1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72773189!with: t1 with: t2 with: t3 with: t4 executeMethod: t5 	<primitive: 189>	^ self withArgs: {t1. t2. t3. t4} executeMethod: t5! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73025430!primitiveClipboardText	<primitive: 141>	^ ''! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73010815!primGetItemMark: t1 item: t2 	<primitive: 'primitiveGetItemMark' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72955663!primSocket: t1 sendUDPData: t2 toHost: t3 port: t4 startIndex: t5 count: t6 	<primitive: 'primitiveSocketSendUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73087567!basicNext	<primitive: 65>	position >= readLimit		ifTrue: [^ nil].	^ collection at: (position := position + 1)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72996725!primPortNameOf: t1 	<primitive: 'primitiveMIDIGetPortName' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73011218!primInvalMenuBar	<primitive: 'primitiveInvalMenuBar' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72966205!setCompositionWindowPositionX: t1 y: t2 	<primitive: 'primSetCompositionWindowPosition' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73104434!primCloseNoError: t1 	<primitive: 'primitiveFileClose' module: 'FilePlugin'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72944170!primitiveFont: t1 getKernPair: t2 	<primitive: 'primitiveFontGetKernPair' module: 'FontPlugin'>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73017634!primLoadBbox: t1 	<primitive: 'primitiveLoadFaceBbox' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73048695!getSystemAttribute: t1 	<primitive: 149>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72929322!closureCopy: t1 copiedValues: t2 	<primitive: 200>	^ BlockClosure		outerContext: self		startpc: pc + 2		numArgs: t1		copiedValues: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73083186!primDecode: t1 frames: t2 from: t3 at: t4 into: t5 at: t6 	<primitive: 'primitiveGSMDecode' module: 'SoundCodecPrims'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73022798!primLoadArraysFrom: t1 	<primitive: 'primitiveLoadOutlineArraysFromFace' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72849308!primReadResult: t1 intoBuffer: t2 at: t3 count: t4 	<primitive: 'primitiveAsyncFileReadResult' module: 'AsynchFilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72994351!primitiveGetMacintoshFileTypeAndCreatorFrom: t1 	<primitive: 'primitiveGetMacintoshFileTypeAndCreatorFrom' module: 'InternetConfigPlugin'>	^ '********' copy! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73011406!primDrawMenuBar	<primitive: 'primitiveDrawMenuBar' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72784209!perform: t1 withArguments: t2 inSuperclass: t3 	<primitive: 100>	t1 isSymbol		ifFalse: [^ self error: 'selector argument must be a Symbol'].	t1 numArgs = t2 size		ifFalse: [^ self error: 'incorrect number of arguments'].	(self class == t3			or: [self class inheritsFrom: t3])		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72912505!primClosePort: t1 	<primitive: 'primitiveSerialPortClose' module: 'SerialPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72849884!yield	| t1 |	<primitive: 167>	t1 := Semaphore new.	[t1 signal] fork.	t1 wait! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73115863!next	<primitive: 65>	self position >= self readLimit		ifTrue: [^ self pastEndRead].	^ self collection		at: (self position: self position + 1)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72776000!tryNamedPrimitive: t1 with: t2 with: t3 with: t4 	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72992662!getPathEnc	<primitive: 'primGetPathEnc' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73083804!primStopRecording	<primitive: 'primitiveSoundStopRecording' module: 'SoundPlugin'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72883119!wordAt: t1 	<primitive: 60>	^ self basicAt: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72988988!primitiveFont: t1 widthOfChar: t2 	<primitive: 'primitiveFontWidthOfChar' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72985093!doProfileStats: t1 	<primitive: 'primitiveDoProfileStats' module: 'B2DPlugin'>	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72997555!primSoundPlaySamples: t1 from: t2 startingAt: t3 	<primitive: 'primitiveSoundPlaySamples' module: 'SoundPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73060833!primitiveCheckSpelling: t1 startingAt: t2 	<primitive: 'primitiveCheckSpelling' module: 'SpellingPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72957074!primSocket: t1 listenOn: t2 backlogSize: t3 	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self destroy! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73011837!primHiliteMenu: t1 	<primitive: 'primitiveHiliteMenu' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72884543!signal	<primitive: 85>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73072705!pluginTransformData: t1 	<primitive: 'primitiveFFTTransformData' module: 'FFTPlugin'>	^ (Smalltalk		at: #FFTPlugin		ifAbsent: [^ self primitiveFailed])		doPrimitive: 'primitiveFFTTransformData'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72843851!primDecodeBlockInto: t1 component: t2 dcTable: t3 acTable: t4 stream: t5 	<primitive: 'primitiveDecodeMCU' module: 'JPEGReaderPlugin'>	^ self		decodeBlockInto: t1		component: t2		dcTable: t3		acTable: t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72961454!cRealExternalCallNaked	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72854465!atWrap: t1 put: t2 	<primitive: 61>	^ self at: t1 - 1 \\ self size + 1 put: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73026516!primGetClipboardFormat: t1 formatNumber: t2 	<primitive: 'ioGetClipboardFormat' module: 'ClipboardExtendedPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73034247!ifCurtailed: t1 	| t2 t3 |	<primitive: 198>	t3 := self valueNoContextSwitch.	t2 := true.	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73041436!disableFileAccess	<primitive: 'primitiveDisableFileAccess' module: 'FilePlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72798030!drawLoopX: t1 Y: t2 	| t3 t4 t5 t6 t7 |	<primitive: 'primitiveDrawLoop' module: 'BitBltPlugin'>	t3 := t1 sign.	t4 := t2 sign.	t5 := t2 abs.	t6 := t1 abs.	t6 > t5		ifTrue: [t7 := t6 // 2.			1				to: t6				do: [:t8 | 					destX := destX + t3.					(t7 := t7 - t5) < 0						ifTrue: [destY := destY + t4.							t7 := t7 + t6].					t8 < t6						ifTrue: [self copyBits]].			nil]		ifFalse: [t7 := t5 // 2.			1				to: t5				do: [:t9 | 					destY := destY + t4.					(t7 := t7 - t6) < 0						ifTrue: [destX := destX + t3.							t7 := t7 + t5].					t9 < t5						ifTrue: [self copyBits]].			nil]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72777317!tryNamedPrimitive	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73051115!quitPrimitive	<primitive: 113>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73041754!primSecureUserDirectory	<primitive: 'primitiveGetSecureUserDirectory' module: 'SecurityPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72799225!copyBitsAgain	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72820895!digitAdd: t1 	| t2 t3 t4 t5 |	<primitive: 'primDigitAdd' module: 'LargeIntegers'>	t4 := 0.	(t2 := self digitLength) < (t3 := t1 digitLength)		ifTrue: [t2 := t3].	t5 := Integer new: t2 neg: self negative.	1		to: t2		do: [:t6 | 			t4 := (t4 bitShift: -8)						+ (self digitAt: t6)						+ (t1 digitAt: t6).			t5				digitAt: t6				put: (t4 bitAnd: 255)].	t4 > 255		ifTrue: [t5 := t5 growby: 1.			t5				at: t5 digitLength				put: (t4 bitShift: -8)].	^ t5! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72959142!primSocket: t1 connectTo: t2 port: t3 	<primitive: 'primitiveSocketConnectToPort' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72915567!primLookupEntryIn: t1 index: t2 	<primitive: 'primitiveDirectoryLookup' module: 'FilePlugin'>	^ #badDirectoryPath! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72981599!stringHash: t1 initialHash: t2 	| t3 t4 t5 |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	self var: #aHash declareC: 'int speciesHash'.	self var: #aString declareC: 'unsigned char *aString'.	t3 := t1 size.	t4 := t2 bitAnd: 268435455.	1		to: t3		do: [:t6 | 			t4 := t4 + (t1 at: t6) asciiValue.			t5 := t4 bitAnd: 16383.			t4 := 9741 * t5 + ((9741							* (t4 bitShift: -14) + (101 * t5) bitAnd: 16383)							* 16384) bitAnd: 268435455].	^ t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73080823!privateEncodeStereo: t1 	<primitive: 'primitiveEncodeStereo' module: 'ADPCMCodecPlugin'>	self inline: false.	self success: false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72965510!instVarOf: t1 at: t2 	<primitive: 73>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72976668!primLocalAddress	<primitive: 'primitiveResolverLocalAddress' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72968367!primCurrencySymbol	<primitive: 'primitiveCurrencySymbol' module: 'LocalePlugin'>	^ '$'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72984632!new	<primitive: 70>	self isVariable		ifTrue: [^ self new: 0].	OutOfMemory signal.	^ self new! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72821498!digitSubtract: t1 	| t2 t3 t4 t5 t6 t7 t8 |	<primitive: 'primDigitSubtract' module: 'LargeIntegers'>	t6 := self digitLength.	t7 := t1 digitLength.	(t6 = t7			ifTrue: [[(self digitAt: t6)						= (t1 digitAt: t6)					and: [t6 > 1]]					whileTrue: [t6 := t6 - 1].				t7 := t6.				(self digitAt: t6)					< (t1 digitAt: t6)]			ifFalse: [t6 < t7])		ifTrue: [t3 := t1.			t2 := self.			t8 := self negative == false.			t6 := t7]		ifFalse: [t3 := self.			t2 := t1.			t8 := self negative].	t5 := Integer new: t6 neg: t8.	t4 := 0.	1		to: t6		do: [:t9 | 			t4 := t4						+ (t3 digitAt: t9)						- (t2 digitAt: t9).			t5 digitAt: t9 put: t4 - (t4 // 256 * 256).			t4 := t4 // 256].	^ t5 normalize! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72960302!primSocketRemoteAddressSize: t1 	<primitive: 'primitiveSocketRemoteAddressSize' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73012443!primShowMenuBar	<primitive: 'primitiveShowMenuBar' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73012629!primSetMenuItemKeyGlyph: t1 item: t2 glyph: t3 	<primitive: 'primitiveSetMenuItemKeyGlyph' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72960518!primSocketCreateNetwork: t1 type: t2 receiveBufferSize: t3 sendBufSize: t4 semaIndex: t5 readSemaIndex: t6 writeSemaIndex: t7 	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore := true.	^ self		primSocketCreateNetwork: t1		type: t2		receiveBufferSize: t3		sendBufSize: t4		semaIndex: t5! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72989789!primitiveCreateFont: t1 size: t2 flags: t3 weight: t4 	<primitive: 'primitiveCreateFont' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72979443!new: t1 	<primitive: 71>	^ self basicNew: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72944577!primitiveStoreSegmentFor: t1 into: t2 outPointers: t3 	<primitive: 98>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72793295!copyBits	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	(combinationRule >= 30			and: [combinationRule <= 31])		ifTrue: [^ self copyBitsTranslucent: 255].	(sourceForm isForm			and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	(destForm isForm			and: [destForm unhibernate])		ifTrue: [^ self copyBits].	(halftoneForm isForm			and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	combinationRule = Form oldPaint		ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape		ifTrue: [^ self eraseBits].	(colorMap notNil			and: [colorMap isColormap])		ifTrue: [colorMap := colorMap colors.			^ self copyBits].	self clipRange		ifTrue: [self roundVariables.			^ self copyBitsAgain].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	self roundVariables.	^ self copyBitsAgain! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73085101!primRecordSamplesInto: t1 startingAt: t2 	<primitive: 'primitiveSoundRecordSamples' module: 'SoundPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73000800!primEnableMenuCommand: t1 command: t2 	<primitive: 'primitiveEnableMenuCommand' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72997259!primSoundGetVolume	<primitive: 'primitiveSoundGetVolume' module: 'SoundPlugin'>	^ Array with: 1.0 with: 1.0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72886916!primAddBezierShape: t1 segments: t2 fill: t3 lineWidth: t4 lineFill: t5 	<primitive: 'primitiveAddBezierShape' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddBezierShape: t1				segments: t2				fill: t3				lineWidth: t4				lineFill: t5].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72938031!isPureTranslation	<primitive: 'primitiveIsPureTranslation' module: 'Matrix2x3Plugin'>	^ self a11 = 1.0		and: [self a12 = 0.0				and: [self a22 = 0.0						and: [self a21 = 1.0]]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72997910!primSoundStop	<primitive: 'primitiveSoundStop' module: 'SoundPlugin'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73002111!primGetMenuItemTextEncoding: t1 item: t2 	<primitive: 'primitiveGetMenuItemTextEncoding' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73084093!primSetRecordLevel: t1 	<primitive: 'primitiveSoundSetRecordLevel' module: 'SoundPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72772645!executeMethod: t1 	<primitive: 189>	^ self withArgs: #() executeMethod: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72994616!class	<primitive: 576>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72871730!objectAt: t1 	<primitive: 68>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72970655!basicNew: t1 	<primitive: 71>	self isVariable		ifFalse: [self error: self printString , ' cannot have variable sized instances'].	(t1 isInteger			and: [t1 >= 0])		ifTrue: [OutOfMemory signal.			^ self basicNew: t1].	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72973801!openContext: t1 label: t2 contents: t3 	<primitive: 19>	ErrorRecursion not & self logDebuggerStackToFile		ifTrue: [Smalltalk				logError: t2				inContext: t1				to: 'PharoDebug.log'].	ErrorRecursion		ifTrue: [ErrorRecursion := false.			self primitiveError: t2].	ErrorRecursion := true.	self informExistingDebugger: t1 label: t2.	(Debugger context: t1)		openNotifierContents: t3		label: t2.	ErrorRecursion := false.	Processor activeProcess suspend! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73002766!primDisposeMenuBar: t1 	<primitive: 'primitiveDisposeMenuBar' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72988172!actualScreenSize	<primitive: 106>	^ 640 @ 480! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73002968!primGetIndMenuWithCommandID: t1 commandID: t2 	<primitive: 'primitiveGetIndMenuWithCommandID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72804793!timesTwoPower: t1 	<primitive: 54>	t1 < -29		ifTrue: [^ self				* (2.0 raisedToInteger: t1)].	t1 < 0		ifTrue: [^ self / (1 bitShift: 0 - t1) asFloat].	t1 < 30		ifTrue: [^ self * (1 bitShift: t1) asFloat].	^ self		* (2.0 raisedToInteger: t1)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72999415!primSoundInsertSamples: t1 from: t2 samplesOfLeadTime: t3 	<primitive: 'primitiveSoundInsertSamples' module: 'SoundPlugin'>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73030102!numCopiedValues	<primitive: 62>	^ self basicSize! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73051465!listLoadedModule: t1 	<primitive: 573>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72837626!>= t1 	<primitive: 26>	^ super >= t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72844801!primImageWidth: t1 	<primitive: 'primImageWidth' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72950837!primSocket: t1 listenOn: t2 	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73017397!primNewMemoryFaceByteSize: t1 index: t2 	<primitive: 'primitiveNewMemoryFaceByteSizeAndIndex' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73015816!errorString	<primitive: 'primitiveErrorString' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73051687!primVmPath	<primitive: 142>	^ ''! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73036267!primSetInputSemaphore: t1 	<primitive: 93>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73051968!setGCSemaphore: t1 	<primitive: 'primitiveSetGCSemaphore'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73074372!primMIDIWritePort: t1 from: t2 at: t3 	<primitive: 'primitiveMIDIWrite' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72880126!replaceFrom: t1 to: t2 with: t3 startingAt: t4 	<primitive: 105>	t3 class == String		ifTrue: [^ self				replaceFrom: t1				to: t2				with: t3 asWideString				startingAt: t4].	^ super		replaceFrom: t1		to: t2		with: t3		startingAt: t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72816647!digitCompare: t1 	| t2 t3 t4 t5 |	<primitive: 'primDigitCompare' module: 'LargeIntegers'>	t2 := self digitLength.	(t3 := t1 digitLength) ~= t2		ifTrue: [t3 > t2				ifTrue: [^ -1].			^ 1].	[t2 > 0]		whileTrue: [(t4 := t1 digitAt: t2) ~= (t5 := self digitAt: t2)				ifTrue: [t4 < t5						ifTrue: [^ 1].					^ -1].			t2 := t2 - 1].	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72904526!primBrowserReady	<primitive: 'primitivePluginBrowserReady'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72787634!species	<primitive: 111>	^ self class! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72893129!primRenderImage: t1 with: t2 	<primitive: 'primitiveRenderImage' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72893375!primGetDepth	<primitive: 'primitiveGetDepth' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72936836!composedWithLocal: t1 into: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 |	<primitive: 'primitiveComposeMatrix' module: 'Matrix2x3Plugin'>	t15 := t1 asMatrixTransform2x3.	t3 := self a11.	t9 := t15 a11.	t4 := self a12.	t10 := t15 a12.	t5 := self a13.	t11 := t15 a13.	t6 := self a21.	t12 := t15 a21.	t7 := self a22.	t13 := t15 a22.	t8 := self a23.	t14 := t15 a23.	t2 a11: t3 * t9 + (t4 * t12).	t2 a12: t3 * t10 + (t4 * t13).	t2 a13: t5 + (t3 * t11) + (t4 * t14).	t2 a21: t6 * t9 + (t7 * t12).	t2 a22: t6 * t10 + (t7 * t13).	t2 a23: t8 + (t6 * t11) + (t7 * t14).	^ t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72951674!primSocketSendDone: t1 	<primitive: 'primitiveSocketSendDone' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72991820!setXWinEnc: t1 	<primitive: 'primSetXWinEnc' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72858685!integerAt: t1 put: t2 	| t3 |	<primitive: 166>	t2 < 0		ifTrue: [t3 := (t2 + 1) negated bitInvert32]		ifFalse: [t3 := t2].	self basicAt: t1 put: t3.	^ t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73004997!primSetMenuItemFontID: t1 item: t2 fontID: t3 	<primitive: 'primitiveSetMenuItemFontID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73038003!primTabletRead: t1 	<primitive: 'primitiveReadTablet' module: 'JoystickTabletPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72978536!relinquishProcessorForMicroseconds: t1 	<primitive: 230>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72790988!primMIDIParameterGet: t1 	<primitive: 'primitiveMIDIParameterGetOrSet' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73005474!primDeleteMenuItem: t1 item: t2 	<primitive: 'primitiveDeleteMenuItem' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73073377!primMIDIReadPort: t1 into: t2 	<primitive: 'primitiveMIDIRead' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72968152!primCountry	<primitive: 'primitiveCountry' module: 'LocalePlugin'>	^ 'FR'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72776332!tryNamedPrimitive: t1 with: t2 with: t3 with: t4 with: t5 with: t6 with: t7 with: t8 	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72989220!primitiveDestroyFont: t1 	<primitive: 'primitiveDestroyFont' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72962957!lDisabledRealExternalCall	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	^ 'Hello World!!'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73005926!primNewMenu: t1 menuTitle: t2 	<primitive: 'primitiveNewMenu' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73052792!isYoung: t1 	<primitive: 'primitiveIsYoung'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73053018!primSignalAtBytesLeft: t1 	<primitive: 125>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72963686!lRealExternalCallNaked	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72961959!cRealExternalCall	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	^ 'Hello World!!'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72809671!sqrt	| t1 t2 t3 t4 |	<primitive: 55>	self <= 0.0		ifTrue: [self = 0.0				ifTrue: [^ 0.0].			^ FloatingPointException signal: 'undefined if less than zero.'].	t1 := self exponent // 2.	t2 := self timesTwoPower: 0 - t1.	t3 := t2 * Epsilon.	t3 := t3 * t3.	t4 := self - (t2 * t2) / (t2 * 2.0).	[t4 * t4 > t3]		whileTrue: [t2 := t2 + t4.			t4 := self - (t2 * t2) / (t2 * 2.0)].	^ t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72844375!primJPEGDecompressStructSize	<primitive: 'primJPEGDecompressStructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72777610!tryNamedPrimitive: t1 with: t2 with: t3 	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73106898!nextPut: t1 	<primitive: 66>	(collection class == ByteString			and: [t1 isCharacter					and: [t1 isOctetCharacter not]])		ifTrue: [collection := WideString from: collection.			^ self nextPut: t1].	position >= writeLimit		ifTrue: [^ self pastEndPut: t1].	position := position + 1.	^ collection at: position put: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73034876!newProcess	<primitive: 19>	^ Process forContext: [self value.		Processor terminateActive] asContext priority: Processor activePriority! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73020233!primTranslateGlyphSlotOutline: t1 	<primitive: 'primitiveTranslateFaceGlyphSlotOutline' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73021532!primMalloc: t1 	<primitive: 'primitiveMallocMemoryFaceData' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73114044!decompressBlock: t1 with: t2 	| t3 t4 t5 t6 t7 t8 t9 |	<primitive: 'primitiveInflateDecompressBlock' module: 'ZipPlugin'>	[self readLimit < self collection size		and: [self sourcePos <= self sourceLimit]]		whileTrue: [t8 := self bitBuf.			t9 := self bitPos.			t7 := self sourcePos.			t3 := self decodeValueFrom: t1.			t3 < 256				ifTrue: [self collection						byteAt: (self readLimit: self readLimit + 1)						put: t3]				ifFalse: [t3 = 256						ifTrue: [self								state: (self state bitAnd: self stateNoMoreData).							^ self].					t4 := (t3 bitShift: -16)								- 1.					t5 := t3 bitAnd: 65535.					t4 > 0						ifTrue: [t5 := t5										+ (self nextBits: t4)].					t3 := self decodeValueFrom: t2.					t4 := t3 bitShift: -16.					t6 := t3 bitAnd: 65535.					t4 > 0						ifTrue: [t6 := t6										+ (self nextBits: t4)].					self readLimit + t5 >= self collection size						ifTrue: [self bitBuf: t8.							self bitPos: t9.							self sourcePos: t7.							^ self].					self collection						replaceFrom: self readLimit + 1						to: self readLimit + t5 + 1						with: self collection						startingAt: self readLimit - t6 + 1.					self readLimit: self readLimit + t5]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72907451!primDropRequestFileName: t1 	<primitive: 'primitiveDropRequestFileName' module: 'DropPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72911174!suspend	| t1 |	<primitive: 88>	myList		ifNil: [^ nil].	t1 := myList.	myList := nil.	t1		remove: self		ifAbsent: [].	^ t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73054510!unbindExternalPrimitives	<primitive: 570>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73055409!gcBiasToGrowLimit: t1 	<primitive: 'primitiveSetGCBiasToGrowGCLimit'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72799511!warpBitsSmoothing: t1 sourceMap: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 |	<primitive: 'primitiveWarpBits' module: 'BitBltPlugin'>	(sourceForm isForm			and: [sourceForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: t1 sourceMap: t2].	(destForm isForm			and: [destForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: t1 sourceMap: t2].	(halftoneForm isForm			and: [halftoneForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: t1 sourceMap: t2].	width < 1 | (height < 1)		ifTrue: [^ self].	t9 := 16384.	t1 > 1		ifTrue: [(destForm depth < 16					and: [colorMap == nil])				ifTrue: [^ self primitiveFailed].			t12 := Array new: t1 * t1].	t13 := height - 1 max: 1.	t3 := (self				deltaFrom: p1x				to: p2x				nSteps: t13)				@ (self						deltaFrom: p1y						to: p2y						nSteps: t13).	t5 := (self				startFrom: p1x				to: p2x				offset: t13 * t3 x)				@ (self						startFrom: p1y						to: p2y						offset: t13 * t3 y).	t4 := (self				deltaFrom: p4x				to: p3x				nSteps: t13)				@ (self						deltaFrom: p4y						to: p3y						nSteps: t13).	t6 := (self				startFrom: p4x				to: p3x				offset: t13 * t4 x)				@ (self						startFrom: p4y						to: p3y						offset: t13 * t4 y).	t10 := BitBlt current bitPeekerFromForm: sourceForm.	t11 := BitBlt current bitPokerToForm: destForm.	t11 clipRect: self clipRect.	t13 := width - 1 max: 1.	destY		to: destY + height - 1		do: [:t20 | 			t7 := (self						deltaFrom: t5 x						to: t6 x						nSteps: t13)						@ (self								deltaFrom: t5 y								to: t6 y								nSteps: t13).			t8 := (self						startFrom: t5 x						to: t6 x						offset: t13 * t7 x)						@ (self								startFrom: t5 y								to: t6 y								offset: t13 * t7 x).			destX				to: destX + width - 1				do: [:t18 | 					t1 = 1						ifTrue: [t11								pixelAt: t18 @ t20								put: (t10 pixelAt: t8 // t9 asPoint)]						ifFalse: [0								to: t1 - 1								do: [:t16 | 0										to: t1 - 1										do: [:t14 | t12												at: t16 * t1 + t14 + 1												put: (t10 pixelAt: t8 + (t7 * t16 // t1) + (t3 * t14 // t1) // t9 asPoint)]].							t11								pixelAt: t18 @ t20								put: (self										mixPix: t12										sourceMap: t2										destMap: colorMap)].					t8 := t8 + t7].			t5 := t5 + t3.			t6 := t6 + t4]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72965664!instVarOf: t1 at: t2 put: t3 	<primitive: 74>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72839838!* t1 	<primitive: 29>	^ super * t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73110377!instVarAt: t1 	<primitive: 73>	^ self basicAt: t1 - self class instSize! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73015628!errorCode	<primitive: 'primitiveErrorCode' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73008743!primDisableMenuItem: t1 item: t2 	<primitive: 'primitiveDisableMenuItem' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72918167!forceDisplayUpdate	<primitive: 231>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72883277!primFill: t1 	<primitive: 145>	self errorImproperStore! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72987671!actualScreenDepth	<primitive: 'primitiveScreenDepth'>	^ Display depth! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73082964!primNewState	<primitive: 'primitiveGSMNewState' module: 'SoundCodecPrims'>	self error: 'The SoundCodecPrims plugin is not available'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73104175!primSetPosition: t1 to: t2 	<primitive: 'primitiveFileSetPosition' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73056067!exitToDebugger	<primitive: 114>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72887985!primSetEdgeTransform: t1 	<primitive: 'primitiveSetEdgeTransform' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73027758!value: t1 	| t2 t3 |	<primitive: 202>	numArgs ~= 1		ifTrue: [self numArgsError: 1].	t2 := self asContextWithSender: thisContext sender.	t3 := self numCopiedValues.	t2 stackp: t3 + 1.	t2 at: 1 put: t1.	1		to: t3		do: [:t4 | t2				at: t4 + 1				put: (self at: t4)].	thisContext privSender: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73027014!value	| t1 t2 |	<primitive: 201>	numArgs ~= 0		ifTrue: [self numArgsError: 0].	t1 := self asContextWithSender: thisContext sender.	(t2 := self numCopiedValues) > 0		ifTrue: [t1 stackp: t2.			1				to: t2				do: [:t3 | t1						at: t3						put: (self at: t3)]].	thisContext privSender: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72945667!primitiveLoadSegmentFrom: t1 outPointers: t2 	<primitive: 99>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72995426!isPluginAvailable	<primitive: 'primitivePluginAvailable' module: 'MD5Plugin'>	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73028506!valueNoContextSwitch	<primitive: 221>	numArgs ~= 0		ifTrue: [self numArgsError: 0].	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73056328!primImageName	<primitive: 121>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73013443!primitiveWindowSize: t1 	<primitive: 'primitiveHostWindowSize' module: 'HostWindowPlugin'>	^ self windowProxyError: 'get size'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72924996!stackp: t1 	<primitive: 76>	self error: 'stackp store failure'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73010560!primSetMenuItemModifiers: t1 item: t2 inModifiers: t3 	<primitive: 'primitiveSetMenuItemModifiers' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72964772!nextInstanceAfter: t1 	<primitive: 78>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72917555!beCursorWithMask: t1 	<primitive: 101>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72875627!getInteger32: t1 	| t2 |	<primitive: 'getInteger' module: 'IntegerPokerPlugin'>	t2 := ((self at: t1) asInteger bitShift: 24)				+ ((self at: t1 + 1) asInteger bitShift: 16)				+ ((self at: t1 + 2) asInteger bitShift: 8) + (self at: t1 + 3) asInteger.	t2 > 1073741824		ifTrue: [^ 1073741824 - t2].	^ t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72992990!requestUTF8	<primitive: 'primIsTextEncUTF8' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72992819!getLocaleEncoding	<primitive: 'primGetLocaleEncoding' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72774533!withArgs: t1 executeMethod: t2 	<primitive: 188>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72843283!primColorConvertGrayscaleMCU: t1 bits: t2 residuals: t3 ditherMask: t4 	<primitive: 'primitiveColorConvertGrayscaleMCU' module: 'JPEGReaderPlugin'>	^ self colorConvertGrayscaleMCU! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72972262!primMillisecondClock	<primitive: 135>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73017825!primGetCharIndex: t1 	<primitive: 'primitiveGetFaceCharIndex' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73018080!primGetPostscriptName	<primitive: 'primitiveGetPostscriptName' module: 'FT2Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72936265!tempAt: t1 put: t2 	<primitive: 211>	^ self at: t1 put: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73056542!snapshotPrimitive	<primitive: 97>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72792883!primMIDIGetClock	<primitive: 'primitiveMIDIGetClock' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72904902!primDropRequestFileHandle: t1 	<primitive: 'primitiveDropRequestFileHandle' module: 'DropPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73015413!primLoadFrom: t1 	<primitive: 'primitiveLoadGlyphSlotFromFace' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72818695!anyBitOfMagnitudeFrom: t1 to: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 |	<primitive: 'primAnyBitFromTo' module: 'LargeIntegers'>	t1 < 1 | (t2 < 1)		ifTrue: [^ self error: 'out of range'].	t3 := self abs.	t8 := t2 min: t3 highBit.	t1 > t8		ifTrue: [^ false].	t4 := t1 - 1 // 8 + 1.	t5 := t8 - 1 // 8 + 1.	t6 := (t1 - 1 \\ 8) negated.	t7 := 7 - (t8 - 1 \\ 8).	t4 = t5		ifTrue: [t10 := (255 bitShift: t6 negated)						bitAnd: (255 bitShift: t7 negated).			t9 := t3 digitAt: t4.			^ (t9 bitAnd: t10)				~= 0].	((t3 digitAt: t4)			bitShift: t6)			~= 0		ifTrue: [^ true].	t4 + 1		to: t5 - 1		do: [:t11 | (t3 digitAt: t11)					~= 0				ifTrue: [^ true]].	(((t3 digitAt: t5)			bitShift: t7)			bitAnd: 255)			~= 0		ifTrue: [^ true].	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73056985!rootTable	<primitive: 'primitiveRootTable'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73018748!primNewFaceFromFile: t1 index: t2 	<primitive: 'primitiveNewFaceFromFileAndIndex' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73026319!primCreateClipboard	<primitive: 'ioCreateClipboard' module: 'ClipboardExtendedPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72974853!primNameLookupResult	<primitive: 'primitiveResolverNameLookupResult' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72967581!primDST	<primitive: 'primitiveDaylightSavings' module: 'LocalePlugin'>	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72988740!primitiveFont: t1 glyphOfChar: t2 into: t3 	<primitive: 'primitiveFontGlyphOfChar' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72956492!primSocketLocalAddress: t1 	<primitive: 'primitiveSocketLocalAddress' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72971955!primSecondsClock	<primitive: 137>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72912722!primWritePort: t1 from: t2 startingAt: t3 count: t4 	<primitive: 'primitiveSerialPortWrite' module: 'SerialPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73033662!ensure: t1 	| t2 t3 |	<primitive: 198>	t3 := self valueNoContextSwitch.	t2		ifNil: [t2 := true.			t1 value].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72859070!integerAt: t1 	| t2 |	<primitive: 165>	t2 := self basicAt: t1.	t2 < 1073741823		ifTrue: [^ t2].	^ t2 >= 2147483648		ifTrue: [(t2 bitInvert32 + 1) negated]		ifFalse: [t2]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73035667!primInterruptSemaphore: t1 	<primitive: 134>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72938363!at: t1 	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^ Float		fromIEEE32Bit: (self basicAt: t1)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72820010!digitMultiply: t1 neg: t2 	| t3 t4 t5 t6 t7 t8 |	<primitive: 'primDigitMultiplyNegative' module: 'LargeIntegers'>	(t1 digitLength = 1			and: [(t1 digitAt: 1)					= 0])		ifTrue: [^ 0].	(self digitLength = 1			and: [(self digitAt: 1)					= 0])		ifTrue: [^ 0].	t4 := self digitLength + t1 digitLength.	t3 := Integer new: t4 neg: t2.	1		to: self digitLength		do: [:t11 | (t6 := self digitAt: t11) ~= 0				ifTrue: [t7 := t11.					t5 := 0.					1						to: t1 digitLength						do: [:t9 | 							t8 := (t1 digitAt: t9)										* t6 + t5										+ (t3 digitAt: t7).							t5 := t8 bitShift: -8.							t3								digitAt: t7								put: (t8 bitAnd: 255).							t7 := t7 + 1].					t3 digitAt: t7 put: t5]].	^ t3 normalize! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72987403!primPathNameDelimiter	<primitive: 'primitiveDirectoryDelimitor' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72987827!depth: t1 width: t2 height: t3 fullscreen: t4 	<primitive: 92>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72963509!lSingularExternalCall	<primitive: 'lSingularExternalCall' module: 'LOne'>	^ 'Hello World!!'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72905505!primURLPost: t1 target: t2 data: t3 semaIndex: t4 	<primitive: 'primitivePluginPostURL'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72972591!open: t1 	<primitive: 19>	self buildMorphicViewOn: t1.	Project spawnNewProcessIfThisIsUI: Processor activeProcess.	^ Processor activeProcess suspend! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72958171!primAcceptFrom: t1 receiveBufferSize: t2 sendBufSize: t3 semaIndex: t4 readSemaIndex: t5 writeSemaIndex: t6 	<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore := true.	^ self		primAcceptFrom: t1		receiveBufferSize: t2		sendBufSize: t3		semaIndex: t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72837292!digitLength	<primitive: 62>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72958736!primSocket: t1 listenOn: t2 backlogSize: t3 interface: t4 	<primitive: 'primitiveSocketListenOnPortBacklogInterface' module: 'SocketPlugin'>	self destroy! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72941676!copy	<primitive: 148>	^ super copy! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73057760!isRoot: t1 	<primitive: 'primitiveIsRoot'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72845008!primJPEGReadHeader: t1 fromByteArray: t2 errorMgr: t3 	<primitive: 'primJPEGReadHeaderfromByteArrayerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72872511!objectAt: t1 put: t2 	<primitive: 69>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73057987!unloadModule: t1 	<primitive: 571>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72897183!primAddActiveEdgeTableEntryFrom: t1 	<primitive: 'primitiveAddActiveEdgeEntry' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self primAddActiveEdgeTableEntryFrom: t1].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72986253!updateAdler32: t1 from: t2 to: t3 in: t4 	| t5 t6 t7 |	<primitive: 'primitiveUpdateAdler32' module: 'ZipPlugin'>	t5 := t1 bitAnd: 65535.	t6 := (t1 bitShift: -16)				bitAnd: 65535.	t2		to: t3		do: [:t8 | 			t7 := t4 byteAt: t8.			t5 := t5 + t7 \\ 65521.			t6 := t6 + t5 \\ 65521].	^ (t6 bitShift: 16)		+ t5! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73013715!primitiveCreateHostWindowWidth: t1 height: t2 originX: t3 y: t4 attributes: t5 	<primitive: 'primitiveCreateHostWindow' module: 'HostWindowPlugin'>	^ self error: 'Unable to create Host Window'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73058367!rootTableAt: t1 	<primitive: 'primitiveRootTableAt'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73073721!primMIDIOpenPort: t1 readSemaIndex: t2 interfaceClockRate: t3 	<primitive: 'primitiveMIDIOpenPort' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72968785!primLongDateFormat	<primitive: 'primitiveLongDateFormat' module: 'LocalePlugin'>	^ 'dddd, mmmm d, yyyy'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72969124!primLanguage	<primitive: 'primitiveLanguage' module: 'LocalePlugin'>	^ 'en'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72845886!primImageHeight: t1 	<primitive: 'primImageHeight' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72772280!tryNamedPrimitive: t1 with: t2 with: t3 with: t4 with: t5 with: t6 with: t7 	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73039840!canWriteImage	<primitive: 'primitiveCanWriteImage' module: 'SecurityPlugin'>	^ true! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72779179!perform: t1 withArguments: t2 	<primitive: 84>	^ self		perform: t1		withArguments: t2		inSuperclass: self class! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73016196!primLoadFields	<primitive: 'primitiveLoadFaceFields' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72949112!primSocket: t1 receiveUDPDataInto: t2 startingAt: t3 count: t4 	<primitive: 'primitiveSocketReceiveUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72835015!\\ t1 	<primitive: 31>	^ super \\ t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72993491!setPathEncToLocale	<primitive: 'primSetPathEncToLocale' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73042263!vmParameterAt: t1 	<primitive: 254>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73109972!becomeHandle	<primitive: 575>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72963143!lFailedCall	<primitive: 'primGetModuleName' module: 'LFailModule'>	^ 'failed call'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72835961!// t1 	<primitive: 32>	^ super // t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72888986!primAddGradientFill: t1 from: t2 along: t3 normal: t4 radial: t5 	<primitive: 'primitiveAddGradientFill' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddGradientFill: t1				from: t2				along: t3				normal: t4				radial: t5].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72889432!primAddExternalFill: t1 	<primitive: 'primitiveRegisterExternalFill' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self primAddExternalFill: t1].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72889923!primFlushNeeded	<primitive: 'primitiveNeedsFlush' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73044637!forgetModule: t1 	<primitive: 571>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72966643!primShortDateFormat	<primitive: 'primitiveShortDateFormat' module: 'LocalePlugin'>	^ 'm/d/yy'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72939426!isIdentity	<primitive: 'primitiveIsIdentity' module: 'Matrix2x3Plugin'>	^ self isPureTranslation		and: [self a13 = 0.0				and: [self a23 = 0.0]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72866872!primSubScalar: t1 	<primitive: 'primitiveSubScalar' module: 'FloatArrayPlugin'>	1		to: self size		do: [:t2 | self at: t2 put: (self at: t2)					- t1]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73110857!nextObject	<primitive: 139>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72993151!setPathEnc: t1 	<primitive: 'primSetPathEnc' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72988528!primitiveFontDescent: t1 	<primitive: 'primitiveFontDescent' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72779636!perform: t1 	<primitive: 83>	^ self		perform: t1		withArguments: (Array new: 0)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73003443!primDisposeMenu: t1 	<primitive: 'primitiveDisposeMenu' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72976251!primStartLookupOfAddress: t1 	<primitive: 'primitiveResolverStartAddressLookup' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72774775!pointsTo: t1 	<primitive: 132>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72890804!primAddCompressedShape: t1 segments: t2 leftFills: t3 rightFills: t4 lineWidths: t5 lineFills: t6 fillIndexList: t7 	<primitive: 'primitiveAddCompressedShape' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddCompressedShape: t1				segments: t2				leftFills: t3				rightFills: t4				lineWidths: t5				lineFills: t6				fillIndexList: t7].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73102205!primFlush: t1 	| t2 |	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>	t2 := self position.	self position: 0;		 position: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73031455!valueWithArguments: t1 	| t2 t3 |	<primitive: 206>	numArgs ~= t1 size		ifTrue: [self numArgsError: t1 size].	t2 := self asContextWithSender: thisContext sender.	t3 := self numCopiedValues.	t2 stackp: t3 + numArgs.	1		to: numArgs		do: [:t4 | t2				at: t4				put: (t1 at: t4)].	1		to: t3		do: [:t5 | t2				at: t5 + numArgs				put: (self at: t5)].	thisContext privSender: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72993664!getXWinEnc	<primitive: 'primGetXWinEnc' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73003877!primDeleteMenu: t1 	<primitive: 'primitiveDeleteMenu' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72911963!floatAt: t1 	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^ Float		fromIEEE32Bit: (self basicAt: t1)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72891559!primSetColorTransform: t1 	<primitive: 'primitiveSetColorTransform' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72868784!primSubArray: t1 	<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>	1		to: self size		do: [:t2 | self at: t2 put: (self at: t2)					- (t1 at: t2)]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72891762!primAddPolygon: t1 segments: t2 fill: t3 lineWidth: t4 lineFill: t5 	<primitive: 'primitiveAddPolygon' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddPolygon: t1				segments: t2				fill: t3				lineWidth: t4				lineFill: t5].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72913331!primReadPort: t1 into: t2 startingAt: t3 count: t4 	<primitive: 'primitiveSerialPortRead' module: 'SerialPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73004303!primCountMenuItems: t1 	<primitive: 'primitiveCountMenuItems' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72871546!atAllPut: t1 	<primitive: 145>	super atAllPut: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72792683!primMIDIGetPortName: t1 	<primitive: 'primitiveMIDIGetPortName' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72892195!primClipRectInto: t1 	<primitive: 'primitiveGetClipRect' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72904353!primURLRequestFileHandle: t1 	<primitive: 'primitivePluginRequestFileHandle'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72951462!primSocket: t1 bindTo: t2 	<primitive: 'primitiveSocketBindTo' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73018256!primSetCharMap: t1 	<primitive: 'primitiveSetFaceCharMap' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72982260!findFirstInString: t1 inSet: t2 startingAt: t3 	| t4 t5 |	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	self var: #aString declareC: 'unsigned char *aString'.	self var: #inclusionMap declareC: 'char *inclusionMap'.	t2 size ~= 256		ifTrue: [^ 0].	t4 := t3.	t5 := t1 size.	[t4 <= t5		and: [(t2 at: (t1 at: t4) asciiValue + 1)				= 0]]		whileTrue: [t4 := t4 + 1].	t4 > t5		ifTrue: [^ 0].	^ t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73026757!primAddClipboardData: t1 data: t2 dataFormat: t3 	<primitive: 'ioAddClipboardData' module: 'ClipboardExtendedPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72844589!primJPEGErrorMgr2StructSize	<primitive: 'primJPEGErrorMgr2StructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72969925!basicNew	<primitive: 70>	self isVariable		ifTrue: [^ self basicNew: 0].	OutOfMemory signal.	^ self basicNew! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72832698!bitShift: t1 	<primitive: 17>	^ super bitShift: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73018454!primGetKerningLeft: t1 right: t2 	<primitive: 'primitiveGetKerningLeftRight' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72937747!localPointToGlobal: t1 	<primitive: 'primitiveTransformPoint' module: 'Matrix2x3Plugin'>	^ (self transformPoint: t1) rounded! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73045305!versionLabel	<primitive: 'primitiveVMVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveVMVersion' translated.	^ ''! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73040164!primUntrustedUserDirectory	<primitive: 'primitiveGetUntrustedUserDirectory' module: 'SecurityPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72984140!translate: t1 from: t2 to: t3 table: t4 	<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>	self var: #table declareC: 'unsigned char *table'.	self var: #aString declareC: 'unsigned char *aString'.	t2		to: t3		do: [:t5 | t1				at: t5				put: (t4 at: (t1 at: t5) asciiValue + 1)]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73025644!primitiveClipboardText: t1 	<primitive: 141>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72965125!someObject	<primitive: 138>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72919305!fullScreenMode: t1 	<primitive: 233>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73005251!primEnableMenuItem: t1 item: t2 	<primitive: 'primitiveEnableMenuItem' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73058588!basicScanCharactersFrom: t1 to: t2 in: t3 rightX: t4 stopConditions: t5 kern: t6 	| t7 t8 t9 t10 t11 t12 t13 |	<primitive: 103>	lastIndex := t1.	t10 := destX.	t11 := Array new: 2.	t13 := false.	[lastIndex <= t2]		whileTrue: [t9 := t3 at: lastIndex.			t7 := t9 asciiValue + 1.			(t5 at: t7)				ifNotNil: [^ t5 at: t7].			t12 := lastIndex + 1 <= t2						ifTrue: [t3 at: lastIndex + 1]						ifFalse: [t13 := true.							lastIndex + 1 <= t3 size								ifTrue: [t3 at: lastIndex + 1]].			font				widthAndKernedWidthOfLeft: t9				right: t12				into: t11.			t8 := t10						+ (t11 at: 1).			t8 > t4				ifTrue: [^ t5 crossedX].			t10 := t10 + t6						+ (t11 at: 2).			t13				ifTrue: [pendingKernX := (t11 at: 2)								- (t11 at: 1).					t10 := t10 - pendingKernX].			destX := t10.			lastIndex := lastIndex + 1].	lastIndex := t2.	^ t5 endOfRun! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72894879!primCopyBufferFrom: t1 to: t2 	<primitive: 'primitiveCopyBuffer' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72942476!primitiveFont: t1 fullWidthOfChar: t2 	<primitive: 'primitiveFontFullWidthOfChar' module: 'FontPlugin'>	^ Array		with: 0		with: (self primitiveFont: t1 widthOfChar: t2)		with: 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73005697!primIsMenuItemEnabled: t1 item: t2 	<primitive: 'primitiveIsMenuItemEnabled' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73046119!primitiveGCBiasToGrow: t1 	<primitive: 'primitiveSetGCBiasToGrow'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73019593!primGetTrackKerningPointSize: t1 degree: t2 	<primitive: 'primitiveGetTrackKerningPointSizeDegree' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73110108!xxxClass	<primitive: 111>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72922938!findNextUnwindContextUpTo: t1 	| t2 |	<primitive: 195>	t2 := self.	[(t2 := t2 sender)		ifNil: [true]		ifNotNil: [t2 == t1]]		whileFalse: [t2 isUnwindContext				ifTrue: [^ t2]].	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72895353!primAddLineFrom: t1 to: t2 leftFillIndex: t3 rightFillIndex: t4 	<primitive: 'primitiveAddLine' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddLineFrom: t1				to: t2				leftFillIndex: t3				rightFillIndex: t4].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73111037!updateCrc: t1 from: t2 to: t3 in: t4 	| t5 |	<primitive: 'primitiveUpdateGZipCrc32' module: 'ZipPlugin'>	t5 := t1.	t2		to: t3		do: [:t6 | t5 := (self crcTable at: ((t5							bitXor: (t4 byteAt: t6))							bitAnd: 255)							+ 1)						bitXor: (t5 bitShift: -8)].	^ t5! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73046479!primImageName: t1 	<primitive: 121>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72952245!primAcceptFrom: t1 receiveBufferSize: t2 sendBufSize: t3 semaIndex: t4 	<primitive: 'primitiveSocketAccept' module: 'SocketPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72809037!exponent	| t1 |	<primitive: 53>	self >= 1.0		ifTrue: [^ self floorLog: 2].	self > 0.0		ifTrue: [t1 := (1.0 / self) exponent.			self = (1.0						/ (1.0 timesTwoPower: t1))				ifTrue: [^ t1 negated].			^ t1 negated - 1].	self = 0.0		ifTrue: [^ -1].	^ self negated exponent! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72952619!primSocketLocalPort: t1 	<primitive: 'primitiveSocketLocalPort' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72963311!lRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72962137!cRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72975575!primAddressLookupResult	<primitive: 'primitiveResolverAddressLookupResult' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72923967!size	<primitive: 212>	^ self primitiveFail! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73007122!primGetItemCmd: t1 item: t2 	<primitive: 'primitiveGetItemCmd' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72919677!primShowRectLeft: t1 right: t2 top: t3 bottom: t4 	<primitive: 127>	self		primRetryShowRectLeft: t1 truncated		right: t2 rounded		top: t3 truncated		bottom: t4 rounded! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73007337!primCheckMenuItem: t1 item: t2 checked: t3 	<primitive: 'primitiveCheckMenuItem' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73035531!copiedValueAt: t1 	<primitive: 60>	^ self basicAt: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73007821!primSetMenuItemHierarchicalID: t1 item: t2 hierID: t3 	<primitive: 'primitiveSetMenuItemHierarchicalID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72778210!tryNamedPrimitive: t1 with: t2 	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73088060!superNextPut: t1 	<primitive: 66>	(collection class == ByteString			and: [t1 isCharacter					and: [t1 isOctetCharacter not]])		ifTrue: [collection := WideString from: collection.			^ self nextPut: t1].	position >= collection size		ifTrue: [^ self pastEndPut: t1].	super		nextPutAll: (Array with: t1).	^ t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73020657!primHasKerning	<primitive: 'primitiveHasKerning' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72781516!primitiveChangeClassTo: t1 	<primitive: 115>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72846095!primJPEGReadImage: t1 fromByteArray: t2 onForm: t3 doDithering: t4 errorMgr: t5 	<primitive: 'primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72914359!primDeleteDirectory: t1 	<primitive: 'primitiveDirectoryDelete' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72924428!terminateTo: t1 	| t2 t3 |	<primitive: 196>	(self hasSender: t1)		ifTrue: [t2 := sender.			[t2 == t1]				whileFalse: [t3 := t2 sender.					t2 terminate.					t2 := t3]].	sender := t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72866384!primMulScalar: t1 	<primitive: 'primitiveMulScalar' module: 'FloatArrayPlugin'>	1		to: self size		do: [:t2 | self at: t2 put: (self at: t2)					* t1]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72964902!replaceIn: t1 from: t2 to: t3 with: t4 startingAt: t5 	<primitive: 105>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72994746!addInstVarName: t1 	<primitive: 577>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73008294!primGetMenuItemHierarchicalID: t1 item: t2 	<primitive: 'primitiveGetMenuItemHierarchicalID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72962641!lRealExternalCall	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	^ 'Hello World!!'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73008542!primGetMenuTitle: t1 	<primitive: 'primitiveGetMenuTitle' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72850661!primAddScalar: t1 and: t2 into: t3 	<primitive: 'primitiveAddScalar' module: 'KedamaPlugin'>	1		to: t1 size		do: [:t4 | t3 at: t4 put: (t1 at: t4)					+ t2].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72850985!primSubScalar: t1 and: t2 into: t3 	<primitive: 'primitiveSubScalar' module: 'KedamaPlugin'>	1		to: t1 size		do: [:t4 | t3 at: t4 put: (t1 at: t4)					- t2].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72867613!primAddArray: t1 	<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>	1		to: self size		do: [:t2 | self at: t2 put: (self at: t2)					+ (t1 at: t2)]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72851309!primMulArray: t1 and: t2 into: t3 	<primitive: 'primitiveMulArrays' module: 'KedamaPlugin'>	1		to: t1 size		do: [:t4 | t3 at: t4 put: (t1 at: t4)					* (t2 at: t4)].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73008968!primGetMenuItemModifiers: t1 item: t2 	<primitive: 'primitiveGetMenuItemModifiers' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72954448!primSocketDestroy: t1 	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72968577!primDecimalSymbol	<primitive: 'primitiveDecimalSymbol' module: 'LocalePlugin'>	^ '.'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73105705!noCheckNextPut: t1 	<primitive: 66>	(collection class == ByteString			and: [t1 isCharacter					and: [t1 isOctetCharacter not]])		ifTrue: [collection := WideString from: collection.			^ self nextPut: t1].	position >= writeLimit		ifTrue: [^ self pastEndPut: t1].	position := position + 1.	^ collection at: position put: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72914680!primGetMacFileNamed: t1 type: t2 creator: t3 	<primitive: 'primitiveDirectoryGetMacTypeAndCreator' module: 'FilePlugin'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73028889!valueNoContextSwitch: t1 	<primitive: 222>	numArgs ~= 1		ifTrue: [self numArgsError: 1].	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72969684!primCurrencyNotation	<primitive: 'primitiveCurrencyNotation' module: 'LocalePlugin'>	^ true! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72792463!primMIDIGetPortDirectionality: t1 	<primitive: 'primitiveMIDIGetPortDirectionality' module: 'MIDIPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72803971!sin	| t1 t2 t3 t4 |	<primitive: 56>	self < 0.0		ifTrue: [^ 0.0 - (0.0 - self) sin].	self > Twopi		ifTrue: [^ (self \\ Twopi) sin].	self > Pi		ifTrue: [^ 0.0 - (self - Pi) sin].	self > Halfpi		ifTrue: [^ (Pi - self) sin].	t1 := t2 := self.	t3 := 0.0 - (self * self).	t4 := 2.0.	[t2 > Epsilon]		whileTrue: [t2 := t2 * t3 / (t4 * (t4 + 1.0)).			t4 := t4 + 2.0.			t1 := t1 + t2.			t2 := t2 * t3 / (t4 * (t4 + 1.0)).			t4 := t4 + 2.0.			t1 := t1 + t2].	^ t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72772890!tryNamedPrimitive: t1 	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72998931!primSoundStartBufferSize: t1 rate: t2 stereo: t3 	<primitive: 'primitiveSoundStart' module: 'SoundPlugin'>	SoundSupported := false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73010096!primGetMenuHandle: t1 	<primitive: 'primitiveGetMenuHandle' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72964211!lDisabledRealExternalCallNaked	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73048510!specialObjectsArray	<primitive: 129>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72796178!primDisplayString: t1 from: t2 to: t3 map: t4 xTable: t5 kern: t6 	| t7 |	<primitive: 'primitiveDisplayString' module: 'BitBltPlugin'>	t2		to: t3		do: [:t8 | 			t7 := (t1 at: t8) asciiValue.			sourceX := t5 at: t7 + 1.			width := (t5 at: t7 + 2)						- sourceX.			self copyBits.			destX := destX + width + t6]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73090599!effectiveNext	<primitive: 65>	position >= readLimit		ifTrue: [^ self pastEndRead].	^ collection at: (position := position + 1)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73036735!primReadJoystick: t1 	<primitive: 'primitiveReadJoystick' module: 'JoystickTabletPlugin'>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72890606!primInitializeBuffer: t1 	<primitive: 'primitiveInitializeBuffer' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72994147!primitiveGetStringKeyedBy: t1 	<primitive: 'primitiveGetStringKeyedBy' module: 'InternetConfigPlugin'>	^ String new! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72940082!at: t1 put: t2 	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	t2 isFloat		ifTrue: [self basicAt: t1 put: t2 asIEEE32BitWord]		ifFalse: [self at: t1 put: t2 asFloat].	^ t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72918818!primitiveDeferUpdates: t1 	<primitive: 126>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72796680!copyBitsColor: t1 alpha: t2 gammaTable: t3 ungammaTable: t4 	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	(sourceForm isForm			and: [sourceForm unhibernate])		ifTrue: [^ self				copyBitsColor: t1				alpha: t2				gammaTable: t3				ungammaTable: t4].	(destForm isForm			and: [destForm unhibernate])		ifTrue: [^ self				copyBitsColor: t1				alpha: t2				gammaTable: t3				ungammaTable: t4].	(halftoneForm isForm			and: [halftoneForm unhibernate])		ifTrue: [^ self				copyBitsColor: t1				alpha: t2				gammaTable: t3				ungammaTable: t4].	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73014560!primitiveWindowPosition: t1 x: t2 y: t3 	<primitive: 'primitiveHostWindowPositionSet' module: 'HostWindowPlugin'>	^ self windowProxyError: 'set position'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72853942!elementsForwardIdentityTo: t1 	<primitive: 72>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73039558!primExpandBlock: t1 into: t2 	<primitive: 'primitiveExpandBlock' module: 'DSAPrims'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72915165!primRename: t1 to: t2 	<primitive: 'primitiveFileRename' module: 'FilePlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72830893!/ t1 	<primitive: 30>	^ super / t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73032319!value: t1 value: t2 value: t3 	| t4 t5 |	<primitive: 204>	numArgs ~= 3		ifTrue: [self numArgsError: 3].	t4 := self asContextWithSender: thisContext sender.	t5 := self numCopiedValues.	t4 stackp: t5 + 3.	t4 at: 1 put: t1.	t4 at: 2 put: t2.	t4 at: 3 put: t3.	1		to: t5		do: [:t6 | t4				at: t6 + 3				put: (self at: t6)].	thisContext privSender: t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72892848!primChangeActiveEdgeTableEntryFrom: t1 	<primitive: 'primitiveChangedActiveEdgeEntry' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72831817!quo: t1 	<primitive: 33>	^ super quo: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73040487!disableSocketAccess	<primitive: 'primitiveDisableSocketAccess' module: 'SocketPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73019365!primEmboldenGlyphSlotOutline: t1 	<primitive: 'primitiveEmboldenFaceGlyphSlotOutline' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72835537!- t1 	<primitive: 22>	^ super - t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72993821!setEncoding: t1 	<primitive: 'primSetEncoding' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72848547!primWriteStart: t1 fPosition: t2 fromBuffer: t3 at: t4 count: t5 	<primitive: 'primitiveAsyncFileWriteStart' module: 'AsynchFilePlugin'>	writeable		ifFalse: [^ self error: 'attempt to write a file opened read-only'].	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73013148!primitiveWindowTitle: t1 string: t2 	<primitive: 'primitiveHostWindowTitle' module: 'HostWindowPlugin'>	^ self error: 'Unable to set title of Host Window'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73040804!hasFileAccess	<primitive: 'primitiveHasFileAccess' module: 'FilePlugin'>	^ true! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73049923!setGCBiasToGrowGCLimit: t1 	<primitive: 'primitiveSetGCBiasToGrowGCLimit'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73050257!primLowSpaceSemaphore: t1 	<primitive: 124>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73069025!applyReverbTo: t1 startingAt: t2 count: t3 	| t4 t5 t6 t7 t8 t9 |	<primitive: 'primitiveApplyReverb' module: 'SoundGenerationPlugin'>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #tapDelays declareC: 'int *tapDelays'.	self var: #tapGains declareC: 'int *tapGains'.	self var: #leftBuffer declareC: 'short int *leftBuffer'.	self var: #rightBuffer declareC: 'short int *rightBuffer'.	t2		to: t2 + t3 - 1		do: [:t11 | 			t4 := t5 := 0.			1				to: tapCount				do: [:t10 | 					t6 := bufferIndex								- (tapDelays at: t10).					t6 < 1						ifTrue: [t6 := t6 + bufferSize].					t7 := tapGains at: t10.					t4 := t4 + (t7									* (leftBuffer at: t6)).					t5 := t5 + (t7									* (rightBuffer at: t6))].			t8 := 2 * t11 - 1.			t9 := (t1 at: t8)						+ (t4 // ScaleFactor).			t9 > 32767				ifTrue: [t9 := 32767].			t9 < -32767				ifTrue: [t9 := -32767].			t1 at: t8 put: t9.			leftBuffer at: bufferIndex put: t9.			t8 := t8 + 1.			t9 := (t1 at: t8)						+ (t5 // ScaleFactor).			t9 > 32767				ifTrue: [t9 := 32767].			t9 < -32767				ifTrue: [t9 := -32767].			t1 at: t8 put: t9.			rightBuffer at: bufferIndex put: t9.			bufferIndex := bufferIndex \\ bufferSize + 1]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72979898!hashBytes: t1 startingWith: t2 	| t3 t4 t5 |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	self var: #aHash declareC: 'int speciesHash'.	self var: #aByteArray declareC: 'unsigned char *aByteArray'.	t3 := t1 size.	t4 := t2 bitAnd: 268435455.	1		to: t3		do: [:t6 | 			t4 := t4						+ (t1 basicAt: t6).			t5 := t4 bitAnd: 16383.			t4 := 9741 * t5 + ((9741							* (t4 bitShift: -14) + (101 * t5) bitAnd: 16383)							* 16384) bitAnd: 268435455].	^ t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72957460!primSocket: t1 connectTo: t2 	<primitive: 'primitiveSocketConnectTo' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73081066!privateDecodeMono: t1 	| t2 t3 t4 t5 |	<primitive: 'primitiveDecodeMono' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	1		to: t1		do: [:t6 | (t6 bitAnd: frameSizeMask)					= 1				ifTrue: [predicted := self nextBits: 16.					predicted > 32767						ifTrue: [predicted := predicted - 65536].					index := self nextBits: 6.					samples at: (sampleIndex := sampleIndex + 1) put: predicted]				ifFalse: [t2 := self nextBits: bitsPerSample.					t3 := stepSizeTable at: index + 1.					t4 := 0.					t5 := deltaValueHighBit.					[t5 > 0]						whileTrue: [(t2 bitAnd: t5)									> 0								ifTrue: [t4 := t4 + t3].							t3 := t3 bitShift: -1.							t5 := t5 bitShift: -1].					t4 := t4 + t3.					(t2 bitAnd: deltaSignMask)							> 0						ifTrue: [predicted := predicted - t4]						ifFalse: [predicted := predicted + t4].					predicted > 32767						ifTrue: [predicted := 32767]						ifFalse: [predicted < -32768								ifTrue: [predicted := -32768]].					index := index								+ (indexTable at: (t2 bitAnd: deltaValueMask)											+ 1).					index < 0						ifTrue: [index := 0]						ifFalse: [index > 88								ifTrue: [index := 88]].					samples at: (sampleIndex := sampleIndex + 1) put: predicted]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72970358!someInstance	<primitive: 77>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72895767!primSetOffset: t1 	<primitive: 'primitiveSetOffset' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72895950!primRenderScanline: t1 with: t2 	<primitive: 'primitiveRenderScanline' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73050588!vmParameterAt: t1 put: t2 	<primitive: 254>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72836855!> t1 	<primitive: 24>	^ super > t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72990032!listFontName: t1 	<primitive: 'primitiveListFont' module: 'FontPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73082691!primEncode: t1 frames: t2 from: t3 at: t4 into: t5 at: t6 	<primitive: 'primitiveGSMEncode' module: 'SoundCodecPrims'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72896735!primMergeFill: t1 from: t2 	<primitive: 'primitiveMergeFillFrom' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72996448!primPortCount	<primitive: 'primitiveMIDIGetPortCount' module: 'MIDIPlugin'>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72785051!shallowCopy	| t1 t2 t3 |	<primitive: 148>	t1 := self class.	t1 isVariable		ifTrue: [t3 := self basicSize.			t2 := t1 basicNew: t3.			[t3 > 0]				whileTrue: [t2						basicAt: t3						put: (self basicAt: t3).					t3 := t3 - 1].			nil]		ifFalse: [t2 := t1 basicNew].	t3 := t1 instSize.	[t3 > 0]		whileTrue: [t2				instVarAt: t3				put: (self instVarAt: t3).			t3 := t3 - 1].	^ t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72962473!cFailedCall	<primitive: 'primGetModuleName' module: 'CFailModule'>	^ 'failed call'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72841847!primitiveCopyFileNamed: t1 to: t2 	| t3 t5 |	<primitive: 'primitiveFileCopyNamedTo' module: 'FileCopyPlugin'>	[| t6 |	[t3 := FileStream readOnlyFileNamed: t1]		on: FileDoesNotExistException		do: [^ self error: 'could not open file ' , t1].	[t5 := FileStream forceNewFileNamed: t2]		on: FileDoesNotExistException		do: [^ self error: 'could not open file ' , t2].	t6 := String new: 50000.	[t3 atEnd]		whileFalse: [t5				nextPutAll: (t3 nextInto: t6)].	nil]		ensure: [t3				ifNotNil: [t3 close].			t5				ifNotNil: [t5 close]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72985507!primitiveSetBitBltPlugin: t1 	<primitive: 'primitiveSetBitBltPlugin' module: 'B2DPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72959563!primSocketCloseConnection: t1 	<primitive: 'primitiveSocketCloseConnection' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72960015!primSocketRemotePort: t1 	<primitive: 'primitiveSocketRemotePort' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72964383!lDisabledRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73022071!primDestroyHandle	<primitive: 'primitiveFreeExternalMemory' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73105497!primSize: t1 	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72885067!wait	<primitive: 86>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72843006!primColorConvertYCbCrMCU: t1 bits: t2 residuals: t3 ditherMask: t4 	<primitive: 'primitiveColorConvertMCU' module: 'JPEGReaderPlugin'>	^ self colorConvertIntYCbCrMCU! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72897542!primNextGlobalEdgeEntryInto: t1 	<primitive: 'primitiveNextGlobalEdgeEntry' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73070587!mixSampleCount: t1 into: t2 startingAt: t3 leftVol: t4 rightVol: t5 	| t6 t7 t8 t9 t10 t11 t12 |	<primitive: 'primitiveMixSampledSound' module: 'SoundGenerationPlugin'>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #samples declareC: 'short int *samples'.	t6 := t3 + t1 - 1.	t7 := t3.	t8 := indexHighBits + (scaledIndex >> IncrementFractionBits).	[t8 <= samplesSize		and: [t7 <= t6]]		whileTrue: [t9 := (samples at: t8)						* scaledVol // ScaleFactor.			t4 > 0				ifTrue: [t10 := 2 * t7 - 1.					t11 := (t2 at: t10)								+ (t9 * t4 // ScaleFactor).					t11 > 32767						ifTrue: [t11 := 32767].					t11 < -32767						ifTrue: [t11 := -32767].					t2 at: t10 put: t11].			t5 > 0				ifTrue: [t10 := 2 * t7.					t11 := (t2 at: t10)								+ (t9 * t5 // ScaleFactor).					t11 > 32767						ifTrue: [t11 := 32767].					t11 < -32767						ifTrue: [t11 := -32767].					t2 at: t10 put: t11].			scaledVolIncr ~= 0				ifTrue: [scaledVol := scaledVol + scaledVolIncr.					((scaledVolIncr > 0								and: [scaledVol >= scaledVolLimit])							or: [scaledVolIncr < 0									and: [scaledVol <= scaledVolLimit]])						ifTrue: [scaledVol := scaledVolLimit.							scaledVolIncr := 0]].			scaledIndex := scaledIndex + scaledIncrement.			scaledIndex >= ScaledIndexOverflow				ifTrue: [t12 := scaledIndex >> IncrementFractionBits.					indexHighBits := indexHighBits + t12.					scaledIndex := scaledIndex - (t12 << IncrementFractionBits)].			t8 := indexHighBits + (scaledIndex >> IncrementFractionBits).			t7 := t7 + 1].	count := count - t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72778863!tryPrimitive: t1 withArgs: t2 	<primitive: 118>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72882068!findSubstring: t1 in: t2 startingAt: t3 matchTable: t4 	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	^ super		findSubstring: t1		in: t2		startingAt: t3		matchTable: t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72886108!primDisplaySpanBuffer	<primitive: 'primitiveDisplaySpanBuffer' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72846438!primOpen: t1 forWrite: t2 semaIndex: t3 	<primitive: 'primitiveAsyncFileOpen' module: 'AsynchFilePlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72946250!primSocketCreateNetwork: t1 type: t2 receiveBufferSize: t3 sendBufSize: t4 semaIndex: t5 	<primitive: 'primitiveSocketCreate' module: 'SocketPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72948329!primSocket: t1 sendData: t2 startIndex: t3 count: t4 	<primitive: 'primitiveSocketSendDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72886346!primGetAALevel	<primitive: 'primitiveGetAALevel' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72966973!primVMOffsetToUTC	<primitive: 'primitiveVMOffsetToUTC' module: 'LocalePlugin'>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72901957!primURLRequestState: t1 	<primitive: 'primitivePluginRequestState'>	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72866628!primAddScalar: t1 	<primitive: 'primitiveAddScalar' module: 'FloatArrayPlugin'>	1		to: self size		do: [:t2 | self at: t2 put: (self at: t2)					+ t1]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72971695!millisecondClockValue	<primitive: 135>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72991653!setTextEnc: t1 	<primitive: 'primSetTextEnc' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72833769!< t1 	<primitive: 23>	^ super < t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72886730!primGetTimes: t1 	<primitive: 'primitiveGetTimes' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72992155!setEncodingToLocale	<primitive: 'primSetEncodingToLocale' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72916835!primPrintHScale: t1 vScale: t2 landscape: t3 	<primitive: 232>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72992330!setTextEncToLocale	<primitive: 'primSetTextEncToLocale' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72995790!convert8bitSignedFrom: t1 to16Bit: t2 	| t3 |	<primitive: 'primitiveConvert8BitSigned' module: 'MiscPrimitivePlugin'>	self var: #aByteArray declareC: 'unsigned char *aByteArray'.	self var: #aSoundBuffer declareC: 'unsigned short *aSoundBuffer'.	1		to: t1 size		do: [:t4 | 			t3 := t1 at: t4.			t3 > 127				ifTrue: [t2						at: t4						put: (t3 - 256 bitShift: 8)]				ifFalse: [t2						at: t4						put: (t3 bitShift: 8)]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72920768!blockCopy: t1 	<primitive: 80>	^ (BlockContext newForMethod: self method)		home: self home		startpc: pc + 2		nargs: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73001288!primGetItemIcon: t1 item: t2 	<primitive: 'primitiveGetItemIcon' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73001505!primSetMenuBar: t1 	<primitive: 'primitiveSetMenuBar' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72888186!primInitializeProcessing	<primitive: 'primitiveInitializeProcessing' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72942969!primitiveFont: t1 getData: t2 	<primitive: 'primitiveGetFontData' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73001704!primAppendMenu: t1 data: t2 	<primitive: 'primitiveAppendMenu' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73001916!primGetMenuID: t1 	<primitive: 'primitiveGetMenuID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72950090!primSocket: t1 listenWithBacklog: t2 	<primitive: 'primitiveSocketListenWithBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73002352!primSetMenuTitle: t1 title: t2 	<primitive: 'primitiveSetMenuTitle' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72921445!basicAt: t1 put: t2 	<primitive: 211>	t1 isInteger		ifTrue: [self errorSubscriptBounds: t1].	t1 isNumber		ifTrue: [^ self at: t1 asInteger put: t2].	self errorNonIntegerIndex! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72813356!digitDiv: t1 neg: t2 	| t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 |	<primitive: 'primDigitDivNegative' module: 'LargeIntegers'>	t1 = 0		ifTrue: [^ (ZeroDivide dividend: self) signal].	t14 := self digitLength - t1 digitLength + 1.	t14 <= 0		ifTrue: [^ Array with: 0 with: self].	t6 := 8 - t1 lastDigit highBitOfPositiveReceiver.	t7 := t1 digitLshift: t6.	t7 := t7 growto: t7 digitLength + 1.	t4 := self digitLshift: t6.	t4 digitLength = self digitLength		ifTrue: [t4 := t4 growto: self digitLength + 1].	t3 := Integer new: t14 neg: t2.	t10 := t7 digitLength - 1.	t5 := t14.	t8 := t7 digitAt: t10.	t9 := t10 = 1				ifTrue: [0]				ifFalse: [t7 digitAt: t10 - 1].	1		to: t5		do: [:t24 | 			t13 := t4 digitLength + 1 - t24.			(t4 digitAt: t13)					= t8				ifTrue: [t11 := t12 := 15]				ifFalse: [t19 := ((t4 digitAt: t13)								bitShift: 4)								+ ((t4 digitAt: t13 - 1)										bitShift: -4).					t11 := t19 // t8.					t19 := (t19 \\ t8 bitShift: 4)								+ ((t4 digitAt: t13 - 1)										bitAnd: 15).					t12 := t19 // t8.					t19 := t19 \\ t8.					t15 := t11 * t9.					t16 := t12 * t9								+ ((t15 bitAnd: 15)										bitShift: 4).					t15 := (t15 bitShift: -4)								+ (t16 bitShift: -8).					t16 := t16 bitAnd: 255.					t17 := t13 < 3								ifTrue: [0]								ifFalse: [t4 digitAt: t13 - 2].					[(t19 < t15							or: [t19 = t15									and: [t17 < t16]])						and: [t12 := t12 - 1.							t16 := t16 - t9.							t16 < 0								ifTrue: [t15 := t15 - 1.									t16 := t16 + 256].							t15 >= t8]]						whileTrue: [t15 := t15 - t8].					t12 < 0						ifTrue: [t11 := t11 - 1.							t12 := t12 + 16]].			t14 := t13 - t10.			t18 := 0.			1				to: t7 digitLength				do: [:t20 | 					t15 := (t7 digitAt: t20)								* t11.					t16 := t18								+ (t4 digitAt: t14)								- ((t15 bitAnd: 15)										bitShift: 4) - ((t7 digitAt: t20)									* t12).					t4 digitAt: t14 put: t16 - (t16 // 256 * 256).					t18 := t16 // 256								- (t15 bitShift: -4).					t14 := t14 + 1].			t18 < 0				ifTrue: [t12 := t12 - 1.					t14 := t13 - t10.					t18 := 0.					1						to: t7 digitLength						do: [:t22 | 							t18 := (t18 bitShift: -8)										+ (t4 digitAt: t14)										+ (t7 digitAt: t22).							t4								digitAt: t14								put: (t18 bitAnd: 255).							t14 := t14 + 1]].			t3 digitAt: t3 digitLength + 1 - t24 put: (t11 bitShift: 4)					+ t12].	t4 := t4				digitRshift: t6				bytes: 0				lookfirst: t10.	^ Array with: t3 with: t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72961618!cSingularExternalCall	<primitive: 'cSingularExternalCall' module: 'COne'>	^ 'Hello World!!'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73002570!primIsMenuBarVisible	<primitive: 'primitiveIsMenuBarVisible' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72938854!globalPointToLocal: t1 	<primitive: 'primitiveInvertPoint' module: 'Matrix2x3Plugin'>	^ (self invertPoint: t1) rounded! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73016779!primGetCharMap	<primitive: 'primitiveGetFaceCharMap' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73020836!primTransformGlyphSlotOutline: t1 	<primitive: 'primitiveTransformFaceGlyphSlotOutline' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73023007!libraryVersion	<primitive: 'primitiveVersion' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73029296!value: t1 value: t2 	| t3 t4 |	<primitive: 203>	numArgs ~= 2		ifTrue: [self numArgsError: 2].	t3 := self asContextWithSender: thisContext sender.	t4 := self numCopiedValues.	t3 stackp: t4 + 2.	t3 at: 1 put: t1.	t3 at: 2 put: t2.	1		to: t4		do: [:t5 | t3				at: t5 + 2				put: (self at: t5)].	thisContext privSender: t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72917208!beCursor	<primitive: 101>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73017199!primSetBitmapLeft: t1 top: t2 	<primitive: 'primitiveSetBitmapLefttop' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72773515!== t1 	<primitive: 110>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73093680!updateHashTable: t1 delta: t2 	| t3 |	<primitive: 'primitiveDeflateUpdateHashTable' module: 'ZipPlugin'>	1		to: t1 size		do: [:t4 | (t3 := t1 at: t4) >= t2				ifTrue: [t1 at: t4 put: t3 - t2]				ifFalse: [t1 at: t4 put: 0]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73003642!primDisableMenuCommand: t1 command: t2 	<primitive: 'primitiveDisableMenuCommand' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72786909!copyFrom: t1 	| t2 t3 |	<primitive: 168>	t2 := self class allInstVarNames.	t3 := t1 class allInstVarNames.	1		to: (t2 size min: t3 size)		do: [:t4 | (t2 at: t4)					= (t3 at: t4)				ifTrue: [self						instVarAt: t4						put: (t1 instVarAt: t4)]].	self class isVariable & t1 class isVariable		ifTrue: [1				to: (self basicSize min: t1 basicSize)				do: [:t6 | self						basicAt: t6						put: (t1 basicAt: t6)]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72922054!findNextHandlerContextStarting	| t1 |	<primitive: 197>	t1 := self.	[t1 isHandlerContext		ifTrue: [^ t1].	(t1 := t1 sender) == nil] whileFalse.	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72845299!primJPEGWriteImage: t1 onByteArray: t2 form: t3 quality: t4 progressiveJPEG: t5 errorMgr: t6 	<primitive: 'primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72971412!flushCache	<primitive: 89>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72852561!primSubArray: t1 and: t2 into: t3 	<primitive: 'primitiveSubArrays' module: 'KedamaPlugin'>	1		to: t1 size		do: [:t4 | t3 at: t4 put: (t1 at: t4)					- (t2 at: t4)].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72922439!basicSize	<primitive: 212>	^ self primitiveFail! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72991987!requestUTF8: t1 	<primitive: 'primSetTextEncUTF8' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73037096!primTabletGetParameters: t1 	<primitive: 'primitiveGetTabletParameters' module: 'JoystickTabletPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72985695!privateCheckForBrowserPrimitives	<primitive: 'primitivePluginBrowserReady'>	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72788523!perform: t1 with: t2 with: t3 	<primitive: 83>	^ self		perform: t1		withArguments: (Array with: t2 with: t3)! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72951944!primSocketRemoteAddress: t1 	<primitive: 'primitiveSocketRemoteAddress' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72867369!primDivScalar: t1 	<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>	1		to: self size		do: [:t2 | self at: t2 put: (self at: t2)					/ t1]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72965260!classOf: t1 	<primitive: 111>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73052556!primitiveGarbageCollect	<primitive: 130>	^ self primBytesLeft! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72962819!lExternalCall1	<primitive: 'prim1' module: 'LPCCT'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72895148!primSetAALevel: t1 	<primitive: 'primitiveSetAALevel' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72991261!primitiveBeep	<primitive: 140>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73006368!primSetItemCmd: t1 item: t2 cmdChar: t3 	<primitive: 'primitiveSetItemCmd' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72989432!primitiveFontEncoding: t1 	<primitive: 'primitiveFontEncoding' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72952905!primSocketError: t1 	<primitive: 'primitiveSocketError' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73053457!snapshotEmbeddedPrimitive	<primitive: 247>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72995066!moduleErrorCode	<primitive: 'primitiveModuleErrorCode' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72975895!primNameResolverStatus	<primitive: 'primitiveResolverStatus' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73103249!primRead: t1 into: t2 startingAt: t3 count: t4 	<primitive: 'primitiveFileRead' module: 'FilePlugin'>	self isClosed		ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73111448!deflateBlock: t1 chainLength: t2 goodMatch: t3 	| t4 t5 t6 t7 t8 t11 t13 t14 |	<primitive: 'primitiveDeflateBlock' module: 'ZipPlugin'>	self blockPosition > t1		ifTrue: [^ false].	t8 := false.	t11 := self blockPosition.	[t11 <= t1]		whileTrue: [t8				ifFalse: [t4 := self								findMatch: t11								lastLength: self minMatch - 1								lastMatch: t11								chainLength: t2								goodMatch: t3.					self insertStringAt: t11.					t13 := t4 bitAnd: 65535.					t14 := t4 bitShift: -16].			t4 := self						findMatch: t11 + 1						lastLength: t14						lastMatch: t13						chainLength: t2						goodMatch: t3.			t6 := t4 bitAnd: 65535.			t7 := t4 bitShift: -16.			(t14 >= t7					and: [t14 >= self minMatch])				ifTrue: [self						assert: [self								validateMatchAt: t11								from: t13								to: t13 + t14 - 1].					t5 := self encodeMatch: t14 distance: t11 - t13.					1						to: t14 - 1						do: [:t9 | self insertStringAt: (t11 := t11 + 1)].					t8 := false.					t11 := t11 + 1]				ifFalse: [t5 := self								encodeLiteral: (self collection byteAt: t11 + 1).					t11 := t11 + 1.					(t11 <= t1							and: [t5 not])						ifTrue: [self insertStringAt: t11.							t8 := true.							t13 := t6.							t14 := t7]].			t5				ifTrue: [self blockPosition: t11.					^ true]].	self blockPosition: t11.	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72817269!bitShiftMagnitude: t1 	| t2 |	<primitive: 'primDigitBitShiftMagnitude' module: 'LargeIntegers'>	t1 >= 0		ifTrue: [^ self digitLshift: t1].	t2 := 0 - t1.	^ (self		digitRshift: (t2 bitAnd: 7)		bytes: (t2 bitShift: -3)		lookfirst: self digitLength) normalize! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72885568!basicReplaceFrom: t1 to: t2 with: t3 startingAt: t4 	<primitive: 105>	t1		to: t2		do: [:t5 | self				basicAt: t5				put: (t3 basicAt: t4 - t1 + t5)]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72862714!decompress: t1 fromByteArray: t2 at: t3 	| t4 t5 t6 t7 t8 t9 t10 t11 |	<primitive: 'primitiveDecompressFromByteArray' module: 'MiscPrimitivePlugin'>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	t4 := t3.	t9 := t2 size.	t10 := 1.	t11 := t1 size + 1.	[t4 <= t9]		whileTrue: [t7 := t2 at: t4.			t4 := t4 + 1.			t7 <= 223				ifFalse: [t7 <= 254						ifTrue: [t7 := t7 - 224 * 256										+ (t2 at: t4).							t4 := t4 + 1]						ifFalse: [t7 := 0.							1								to: 4								do: [:t12 | 									t7 := (t7 bitShift: 8)												+ (t2 at: t4).									t4 := t4 + 1].							nil]].			t6 := t7 >> 2.			t10 + t6 > t11				ifTrue: [^ self primitiveFail].			t5 := t7 bitAnd: 3.			t5 = 0.			t5 = 1				ifTrue: [t8 := t2 at: t4.					t4 := t4 + 1.					t8 := t8								bitOr: (t8 bitShift: 8).					t8 := t8								bitOr: (t8 bitShift: 16).					1						to: t6						do: [:t13 | 							t1 at: t10 put: t8.							t10 := t10 + 1]].			t5 = 2				ifTrue: [t8 := 0.					1						to: 4						do: [:t14 | 							t8 := (t8 bitShift: 8)										bitOr: (t2 at: t4).							t4 := t4 + 1].					1						to: t6						do: [:t15 | 							t1 at: t10 put: t8.							t10 := t10 + 1]].			t5 = 3				ifTrue: [1						to: t6						do: [:t17 | 							t8 := 0.							1								to: 4								do: [:t16 | 									t8 := (t8 bitShift: 8)												bitOr: (t2 at: t4).									t4 := t4 + 1].							t1 at: t10 put: t8.							t10 := t10 + 1]]]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72962335!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72987019!primSignal: t1 atMilliseconds: t2 	<primitive: 136>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73006609!primSetItemMark: t1 item: t2 markChar: t3 	<primitive: 'primitiveSetItemMark' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72896997!primGetClipRect: t1 	<primitive: 'primitiveGetClipRect' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73041942!disableImageWrite	<primitive: 'primitiveDisableImageWrite' module: 'SecurityPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72912973!primOpenPort: t1 baudRate: t2 stopBitsType: t3 parityType: t4 dataBits: t5 inFlowControlType: t6 outFlowControlType: t7 xOnByte: t8 xOffByte: t9 	<primitive: 'primitiveSerialPortOpen' module: 'SerialPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72828568!asFloat	<primitive: 40>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72777931!with: t1 with: t2 executeMethod: t3 	<primitive: 189>	^ self withArgs: {t1. t2} executeMethod: t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72851639!primDivArray: t1 and: t2 into: t3 	<primitive: 'primitiveDivArrays' module: 'KedamaPlugin'>	1		to: t1 size		do: [:t4 | t3 at: t4 put: (t1 at: t4)					/ (t2 at: t4)].	^ t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73039238!primHashBlock: t1 using: t2 	<primitive: 'primitiveHashBlock' module: 'DSAPrims'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72940390!= t1 	| t2 |	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>	self class = t1 class		ifFalse: [^ false].	t2 := self size.	t2 = t1 size		ifFalse: [^ false].	1		to: self size		do: [:t3 | (self at: t3)					= (t1 at: t3)				ifFalse: [^ false]].	^ true! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72920155!beDisplay	<primitive: 102>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72953626!primSocketConnectionStatus: t1 	<primitive: 'primitiveSocketConnectionStatus' module: 'SocketPlugin'>	^ InvalidSocket! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72954212!primSocket: t1 localAddressResult: t2 	<primitive: 'primitiveSocketLocalAddressResult' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73053756!interpreterSourceVersion	<primitive: 'primitiveInterpreterSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveInterpreterSourceVersion' translated.	^ ''! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73054979!bytesLeft: t1 	<primitive: 112>	^ self primBytesLeft! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72856622!atWrap: t1 	<primitive: 60>	^ self at: t1 - 1 \\ self size + 1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72990211!primInitializeNetwork: t1 	<primitive: 'primitiveInitializeNetwork' module: 'SocketPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72778520!tryNamedPrimitive: t1 with: t2 with: t3 with: t4 with: t5 	<primitive: '' module: ''>	^ ContextPart primitiveFailToken! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72840261!<= t1 	<primitive: 25>	^ super <= t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72831403!~= t1 	<primitive: 8>	^ super ~= t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73055651!getVMParameters	<primitive: 254>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72966409!primMeasurement	<primitive: 'primitiveMeasurementMetric' module: 'LocalePlugin'>	^ true! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73015992!primLoadCharacter: t1 flags: t2 	<primitive: 'primitiveLoadCharacter' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72876361!findSubstringViaPrimitive: t1 in: t2 startingAt: t3 matchTable: t4 	| t5 |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	self var: #key declareC: 'unsigned char *key'.	self var: #body declareC: 'unsigned char *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	t1 size = 0		ifTrue: [^ 0].	t3		to: t2 size - t1 size + 1		do: [:t6 | 			t5 := 1.			[(t4 at: (t2 at: t6 + t5 - 1) asciiValue + 1)				= (t4 at: (t1 at: t5) asciiValue + 1)]				whileTrue: [t5 = t1 size						ifTrue: [^ t6].					t5 := t5 + 1]].	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73107766!nextBytePut: t1 	<primitive: 66>	position >= writeLimit		ifTrue: [^ self pastEndPut: t1].	position := position + 1.	^ collection byteAt: position put: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72941837!primitiveFontNumKernPairs: t1 	<primitive: 'primitiveFontNumKernPairs' module: 'FontPlugin'>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72975167!primStartLookupOfName: t1 	<primitive: 'primitiveResolverStartNameLookup' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72795399!copyBitsTranslucent: t1 	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	(sourceForm isForm			and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: t1].	(destForm isForm			and: [destForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: t1].	(halftoneForm isForm			and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: t1].	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73038948!primHasSecureHashPrimitive	<primitive: 'primitiveHasSecureHashPrimitive' module: 'DSAPrims'>	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72982851!indexOfAscii: t1 inString: t2 startingAt: t3 	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned char *aString'.	t3		to: t2 size		do: [:t4 | (t2 at: t4) asciiValue = t1				ifTrue: [^ t4]].	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72802289!@ t1 	<primitive: 18>	^ Point x: self y: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72888463!primGetCounts: t1 	<primitive: 'primitiveGetCounts' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72943384!primitiveFontDataSize: t1 	<primitive: 'primitiveFontDataSize' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72902365!primURLRequest: t1 target: t2 semaIndex: t3 	<primitive: 'primitivePluginRequestURL'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72983327!compare: t1 with: t2 collated: t3 	| t4 t5 t6 t7 |	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	self var: #string1 declareC: 'unsigned char *string1'.	self var: #string2 declareC: 'unsigned char *string2'.	self var: #order declareC: 'unsigned char *order'.	t4 := t1 size.	t5 := t2 size.	1		to: (t4 min: t5)		do: [:t8 | 			t6 := t3 at: (t1 basicAt: t8)							+ 1.			t7 := t3 at: (t2 basicAt: t8)							+ 1.			t6 = t7				ifFalse: [t6 < t7						ifTrue: [^ 1].					^ 3]].	t4 = t5		ifTrue: [^ 2].	t4 < t5		ifTrue: [^ 1].	^ 3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72993990!getTextEnc	<primitive: 'primGetTextEnc' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73009387!primSetItemStyle: t1 item: t2 styleParameter: t3 	<primitive: 'primitiveSetItemStyle' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73036530!primGetNextEvent: t1 	<primitive: 94>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73009637!primCreateStandardWindowMenu: t1 	<primitive: 'primitiveCreateStandardWindowMenu' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72836476!bitAnd: t1 	<primitive: 14>	^ super bitAnd: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72880987!byteAt: t1 	<primitive: 60>	^ (self at: t1) asciiValue! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72954740!primSocket: t1 getOption: t2 	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72955235!primSocket: t1 receiveDataInto: t2 startingAt: t3 count: t4 	<primitive: 'primitiveSocketReceiveDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73009861!primGetMenuItemCommandID: t1 item: t2 	<primitive: 'primitiveGetMenuItemCommandID' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72967351!primDigitGrouping	<primitive: 'primitiveDigitGroupingSymbol' module: 'LocalePlugin'>	^ ','! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72890283!primNextFillEntryInto: t1 	<primitive: 'primitiveNextFillEntry' module: 'B2DPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72988318!primitiveFontAscent: t1 	<primitive: 'primitiveFontAscent' module: 'FontPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72925715!doPrimitive: t1 method: t2 receiver: t3 args: t4 	| t5 |	<primitive: 19>	t1 = 19		ifTrue: [SimulationGuardException new method: t2;				 receiver: t3;				 args: t4;				 signal].	(t1 = 80			and: [t3 isKindOf: ContextPart])		ifTrue: [^ self				push: ((BlockContext newForMethod: t3 method)						home: t3 home						startpc: pc + 2						nargs: (t4 at: 1))].	(t1 = 81			and: [t3 isMemberOf: BlockContext])		ifTrue: [^ t3 pushArgs: t4 from: self].	(t1 = 82			and: [t3 isMemberOf: BlockContext])		ifTrue: [^ t3 pushArgs: t4 first from: self].	t1 = 83		ifTrue: [^ self				send: t4 first				to: t3				with: t4 allButFirst				super: false].	t1 = 84		ifTrue: [^ self				send: t4 first				to: t3				with: (t4 at: 2)				super: false].	t1 = 188		ifTrue: [^ MethodContext				sender: self				receiver: t3				method: (t4 at: 2)				arguments: (t4 at: 1)].	(t1 = 200			and: [t3 == self])		ifTrue: [^ self				push: (BlockClosure						outerContext: t3						startpc: pc + 2						numArgs: t4 first						copiedValues: t4 last)].	((t1 between: 201 and: 205)			or: [t1 between: 221 and: 222])		ifTrue: [^ t3 simulateValueWithArguments: t4 caller: self].	t1 = 206		ifTrue: [^ t3 simulateValueWithArguments: t4 first caller: self].	t1 = 120		ifTrue: [t5 := t2 literals first tryInvokeWithArguments: t4]		ifFalse: [t4 size > 6				ifTrue: [^ PrimitiveFailToken].			t5 := t1 = 117						ifTrue: [self								tryNamedPrimitiveIn: t2								for: t3								withArgs: t4]						ifFalse: [t3 tryPrimitive: t1 withArgs: t4]].	^ t5 == PrimitiveFailToken		ifTrue: [PrimitiveFailToken]		ifFalse: [self push: t5]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72774200!nextInstance	<primitive: 78>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73011032!primHideMenuBar	<primitive: 'primitiveHideMenuBar' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72853399!elementsForwardIdentityTo: t1 copyHash: t2 	<primitive: 249>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73104678!primTruncate: t1 to: t2 	<primitive: 'primitiveFileTruncate' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72775697!with: t1 with: t2 with: t3 executeMethod: t4 	<primitive: 189>	^ self withArgs: {t1. t2. t3} executeMethod: t4! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72843643!primIdctInt: t1 qt: t2 	<primitive: 'primitiveIdctInt' module: 'JPEGReaderPlugin'>	^ self idctBlockInt: t1 qt: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72912185!floatAt: t1 put: t2 	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	t2 isFloat		ifTrue: [self basicAt: t1 put: t2 asIEEE32BitWord]		ifFalse: [self at: t1 put: t2 asFloat].	^ t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72995598!primitiveGetUniqueSpellingTag	<primitive: 'primitiveGetUniqueSpellingTag' module: 'SpellingPlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72830404!digitAt: t1 	<primitive: 60>	self digitLength < t1		ifTrue: [^ 0].	^ super at: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72974665!primJPEGPluginIsPresent	<primitive: 'primJPEGPluginIsPresent' module: 'JPEGReadWriter2Plugin'>	^ false! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72892677!primGetFailureReason	<primitive: 'primitiveGetFailureReason' module: 'B2DPlugin'>	^ 0! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72961296!cExternalCall2	<primitive: 'prim2' module: 'CPCCT'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72832322!bitOr: t1 	<primitive: 15>	^ super bitOr: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72789438!instVarAt: t1 put: t2 	<primitive: 74>	^ self basicAt: t1 - self class instSize put: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72893549!primAddBezierFrom: t1 to: t2 via: t3 leftFillIndex: t4 rightFillIndex: t5 	<primitive: 'primitiveAddBezier' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddBezierFrom: t1				to: t2				via: t3				leftFillIndex: t4				rightFillIndex: t5].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72992503!getEncoding	<primitive: 'primGetEncoding' module: 'ImmX11Plugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73011592!primSetMenuItemText: t1 item: t2 itemString: t3 	<primitive: 'primitiveSetMenuItemText' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73012885!primitiveWindowPosition: t1 	<primitive: 'primitiveHostWindowPosition' module: 'HostWindowPlugin'>	^ self windowProxyError: 'get position'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73021347!primCurrentLibrary	<primitive: 'primitiveLibraryHandle' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72893987!primAddBitmapFill: t1 colormap: t2 tile: t3 from: t4 along: t5 normal: t6 xIndex: t7 	<primitive: 'primitiveAddBitmapFill' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddBitmapFill: t1				colormap: t2				tile: t3				from: t4				along: t5				normal: t6				xIndex: t7].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72972935!openInterrupt: t1 onProcess: t2 	| t3 |	<primitive: 19>	t3 := self new.	t3		process: t2		controller: nil		context: t2 suspendedContext.	t3 externalInterrupt: true.	self logDebuggerStackToFile		ifTrue: [(t1 includesSubString: 'Space')					& (t1 includesSubString: 'low')				ifTrue: [Smalltalk						logError: t1						inContext: t3 interruptedContext						to: 'LowSpaceDebug.log']].	^ t3 openNotifierContents: nil label: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72894453!primAddOvalFrom: t1 to: t2 fillIndex: t3 borderWidth: t4 borderColor: t5 	<primitive: 'primitiveAddOval' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason)		ifTrue: [^ self				primAddOvalFrom: t1				to: t2				fillIndex: t3				borderWidth: t4				borderColor: t5].	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72956750!primSocketDestroyGently: t1 	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72969341!primTimeFormat	<primitive: 'primitiveTimeFormat' module: 'LocalePlugin'>	^ 'h:mmx'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72808096!truncated	| t1 t2 t3 t4 |	<primitive: 51>	(self isInfinite			or: [self isNaN])		ifTrue: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: [t1 := (SmallInteger maxVal bitShift: -1)						+ 1.			t2 := t1 asFloat.			t3 := self quo: t2.			t4 := self - (t3 asFloat * t2).			^ t3 * t1 + t4 truncated].	^ self asTrueFraction! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73019832!primLoadGlyph: t1 flags: t2 	<primitive: 'primitiveLoadGlyph' module: 'FT2Plugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72998192!primSoundStartBufferSize: t1 rate: t2 stereo: t3 semaIndex: t4 	<primitive: 'primitiveSoundStartWithSemaphore' module: 'SoundPlugin'>	UseReadySemaphore := false.	self		primSoundStartBufferSize: t1		rate: t2		stereo: t3! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72776708!with: t1 executeMethod: t2 	<primitive: 189>	^ self withArgs: {t1} executeMethod: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72854700!elementsExchangeIdentityWith: t1 	<primitive: 128>	t1 class == Array		ifFalse: [^ self error: 'arg must be array'].	self size = t1 size		ifFalse: [^ self error: 'arrays must be same size'].	(self			anySatisfy: [:t2 | t2 class == SmallInteger])		ifTrue: [^ self error: 'can''t become SmallIntegers'].	(t1			anySatisfy: [:t2 | t2 class == SmallInteger])		ifTrue: [^ self error: 'can''t become SmallIntegers'].	self		with: t1		do: [:t2 :t3 | 			t2 == t3				ifTrue: [^ self error: 'can''t become yourself'].			nil].	(Smalltalk bytesLeft: true)			= Smalltalk primitiveGarbageCollect		ifTrue: [^ self primitiveFailed].	^ self elementsExchangeIdentityWith: t1! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72964022!lExternalCallWithoutModule	<primitive: 'primGetModuleName'>	^ 'Hello World!!'! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73104936!primAtEnd: t1 	<primitive: 'primitiveFileAtEnd' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73057247!listBuiltinModule: t1 	<primitive: 572>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73084522!primStartRecordingDesiredSampleRate: t1 stereo: t2 semaIndex: t3 	<primitive: 'primitiveSoundStartRecording' module: 'SoundPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72957678!primSocket: t1 setPort: t2 	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72939148!hash	| t1 |	<primitive: 'primitiveHashArray' module: 'FloatArrayPlugin'>	t1 := 0.	1		to: self size		do: [:t2 | t1 := t1						+ (self basicAt: t2)].	^ t1 bitAnd: 536870911! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72810859!ln	| t1 t2 t3 t4 t5 t6 t7 t8 t9 |	<primitive: 58>	self <= 0.0		ifTrue: [self error: 'ln is only defined for x > 0.0'].	t1 := self exponent.	t2 := Ln2 * t1.	t3 := self timesTwoPower: 0 - t1.	t4 := t3 - 1.0.	t5 := 1.0.	t6 := t7 := t8 := t4.	t4 := t4 negated.	t9 := Epsilon * (t2 abs + 1.0).	[t7 > t9]		whileTrue: [t5 := t5 + 1.0.			t6 := t6 * t4.			t7 := t6 / t5.			t8 := t8 + t7.			t5 := t5 + 1.0.			t6 := t6 * t4.			t7 := t6 / t5.			t8 := t8 + t7].	^ t2 + t8! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73105192!primSizeNoError: t1 	<primitive: 'primitiveFileSize' module: 'FilePlugin'>	^ nil! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73026092!primReadClipboardData: t1 format: t2 	<primitive: 'ioReadClipboardData' module: 'ClipboardExtendedPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73057471!garbageCollectMost	<primitive: 131>	^ self primBytesLeft! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72877913!byteAt: t1 put: t2 	<primitive: 61>	self at: t1 put: t2 asCharacter.	^ t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72867116!primDivArray: t1 	<primitive: 'primitiveDivFloatArray' module: 'FloatArrayPlugin'>	1		to: self size		do: [:t2 | self at: t2 put: (self at: t2)					/ (t1 at: t2)]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73012030!primClearMenuBar	<primitive: 'primitiveClearMenuBar' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72916508!primCreateDirectory: t1 	<primitive: 'primitiveDirectoryCreate' module: 'FilePlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73012218!primGetMenuItemText: t1 item: t2 	<primitive: 'primitiveGetMenuItemText' module: 'MacMenubarPlugin'>	self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73000467!primSoundSetVolumeLeft: t1 volumeRight: t2 	<primitive: 'primitiveSoundSetLeftVolume' module: 'SoundPlugin'>	^ self! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73025884!primClearClipboard: t1 	<primitive: 'ioClearClipboard' module: 'ClipboardExtendedPlugin'>	^ self primitiveFailed! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72879942!wordAt: t1 put: t2 	<primitive: 61>	self basicAt: t1 put: t2! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72869195!primMulArray: t1 	<primitive: 'primitiveMulFloatArray' module: 'FloatArrayPlugin'>	1		to: self size		do: [:t2 | self at: t2 put: (self at: t2)					* (t1 at: t2)]! !!PrimitivesScope methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 72920494!supportsDisplayDepth: t1 	<primitive: 91>	^ #(1 2 4 8 16 32 ) includes: t1! !!PrimitivesScopeTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73269985!testBeeper	self		should: [MyBeeper primitiveBeep]		raise: MessageNotUnderstood.	self		shouldnt: [(PrimitivesScope mirrorFor: MyBeeper) primitiveBeep]		raise: MessageNotUnderstood! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33653514!testSelf"	| t1 t2 |	t2 := #self.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47914577!tearDown	PropagationTestClass removeSelector: #testToRemove! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33654398!testSendToSelf"	| t1 t2 |	t2 := #sendToSelf.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33655729!testTemp"	| t1 t2 |	t2 := #temp.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47919477!setUp	RewriteMethodWithPropagationHandle resetAll! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33652651!testCreationMethodOnOriginate	"| t1 t2 t3 |	t3 := PropagationTestClass new.	t1 := RewriteMethodWithPropagationHandle				for: t3				rule: [].	PropagationTestClass compile: 'testToRemove ^false'.	self		should: [t1 testToRemove]		raise: MessageNotUnderstood.	self		shouldnt: [t3 testToRemove]		raise: MessageNotUnderstood"! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33653073!testInstVar"	| t1 t2 |	t2 := #instanceVar.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33653945!testSendToInstVar"	| t1 t2 |	t2 := #sendToInstanceVar.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33654841!testSendToSuper"	| t1 t2 |	t2 := #sendToSuper.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33655286!testSendToTemp"	| t1 t2 |	t2 := #sendToTemp.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!RewriteMethodHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47127110!rewriteDictionaryOf: t1 putIn: t2 with: t3 	t1 methodDict		do: [:t4 | t2				compile: (t3 value: t4)]! !!RewriteMethodHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47554518!rewrite: t1 withRule: t2 	self		storeAt: t1 class		ifAbsent: [| t3 t5 |			t3 := OrderedCollection new.			t1 class				allSuperclassesDo: [:t6 | t3 add: t6].			t3 addFirst: t1 class.			t3 := t3 reverse.			t5 := UndefinedObject.			t3				do: [:t6 | t5 := self								storeAt: t6								ifAbsent: [| t7 |									t7 := Behavior new setFormat: t6 format;												 superclass: t5;												 methodDict: MethodDictionary new.									self										rewriteDictionaryOf: t6										putIn: t7										with: t2.									self storeAt: t6 put: t7.									t7]]].	^ self storeAt: t1 class! !!RewriteMethodHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47541773!debugFor: t1 to: t2 	self error: 'This class doesnt work with this interface use #debugFor:rule selector'! !!RewriteMethodHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47545361!for: t1 rule: t2 	| t3 |	t1 isLiteral		ifTrue: [^ t1].	t3 := self debugFor: t1 rule: t2.	[t3 becomeHandle]		on: Exception		do: [].	^ t3! !!RewriteMethodHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47552751!debugFor: t1 rule: t2 	| t3 t4 |	t3 := self createHandle.	t4 := t3 rewrite: t1 withRule: t2.	t3 initializeHandleWith: t1 to: t4.	^ t3! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47533285!matchingMessageSelfRule	^ ' self `@message: `@args'! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47203680!rule	^ state! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47198384!rule: t1 	state := t1! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47437479!matchingMessageSuperSendRule	^ ' super `@message: `@args'! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47800527!rewritingMessageSelfRule	^ '(' , self class printString , ' for: self rule: ' , self rule printString , ' ) `@message: `@args'! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47800999!propagate: t1 through: t2 	| t3 t4 t5 t6 |	t3 := RBParseTreeRewriter new.	t3 replace: self matchingMessageSuperSendRule with: self rewritingMessageSuperSendRule.	t3 replace: self matchingMessageSelfRule with: self rewritingMessageSelfRule.	t2		do: [:t7 | t3 replace: t7 , '`@message: `@args' with: '(' , self class printString , ' for: ' , t7 , ' rule: ' , self rule printString , ') `@message: `@args'].	t4 := t3				executeTree: (RBParser parseMethod: t1);				 tree.	^ t4 formattedCode! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47534049!rewriteDictionaryOf: t1 putIn: t2 with: t3 	| t4 |	t1 methodDict		do: [:t5 | 			| t6 |			t6 := t5 getSource.			t6 := self propagate: t6 through: t1 instVarNames.			[t2 compile: t6]				on: Error				do: [Transcript show: t5 selector;						 cr]]! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47082794!initialize	^ super initialize! !!RewriteMethodWithPropagationHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47800763!rewritingMessageSuperSendRule	^ '(' , self class printString , ' superFor: self rule: ' , self rule printString , ' ) `@message: `@args'! !!RewriteMethodWithPropagationHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47552417!debugFor: t1 rule: t2 	| t3 t4 |	t3 := self createHandle.	t3 rule: t2.	t4 := t3 rewrite: t1 withRule: t2.	t3 initializeHandleWith: t1 to: t4.	^ t3! !!StructuralHandleClass class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70906338!class	<primitive: 576>	self primitiveFailed! !!StructuralHandleClass class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70906940!addInstVarName: t1 	<primitive: 577>	self primitiveFailed! !!SubclassOfHelloWorld methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 47417487!upHelloWorld	^ 'upHello in SubClassOfHelloWorld'! !!TransactionalHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70837177!initialize	super initialize.	self addState.	self addBehavior! !!TransactionalHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70847216!debugFor: t1 	| t2 t3 |	t1 isLiteral		ifTrue: [^ t1].	t2 := self createHandle.	t3 := Class new setFormat: t1 class format;				 superclass: t1 class superclass;				 setName: 'TM' , t1 class name;				 methodDict: t1 class methodDict.	t2 initializeHandleWith: t1 to: t3.	^ t2! !!TransactionalManager methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70851168!execute: t1 	| t2 |	t2 := self prepareCode: t1.	t2 doIt! !!TransactionalManager methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70850691!initialize	classToBrowse := Dictionary new.	objectPool := Dictionary new! !!TransactionalManager methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70854101!addClass: t1 	| t2 t3 t4 |	t4 := 'TM_' , t1 name.	t2 := Class new setFormat: t1 format;				 superclass: t1 superclass;				 setName: t4.	t3 := t1 methodDict copy				collect: [:t5 | 					t5 methodClass: t2.					t5].	t2 methodDict: t3.	classToBrowse at: t1 put: t2! !!TransactionalManager methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70848987!addObject: t1 	| t2 |	self addClass: t1 class.	t2 := TransactionalHandle debugFor: t1.	objectPool at: t1 put: t2! !!TransactionalManager class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 70851327!for: t1 	| t2 |	t2 := self new.	t1		do: [:t3 | t2 addClass: t3].	^ t2! !!TranscriptWatcher class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73198382!detectRule	^ '`@methodName: `@methodArgs     | `@Temps |     `@Statements'! !!TranscriptWatcher class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33663972!InitializeWatcherFor: aObject 	| behavior treeRewriter |	treeRewriter := RBParseTreeRewriter new.	treeRewriter replaceMethod: self detectRule with: self replaceRule.	behavior := Behavior new setFormat: aObject class format;				 superclass: aObject class;				 methodDict: MethodDictionary new.	aObject class methodDict		do: [:method | 			| tree |			tree := treeRewriter						executeTree: (RBParser parseMethod: method getSource);						 tree.			behavior compile: tree formattedCode].	^ behavior! !!TranscriptWatcher class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 73249978!replaceRule	^ '`@methodName: `@methodArgs     | `@Temps |	Transcript show: ''message send '',[self `@methodName: `@methodArgs ] asString.	Transcript cr.	^super `@methodName: `@methodArgs.'! !!Watcher class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33664577!watch: aObject 	| watcher aClass meta |	watcher := self new.	aClass := self InitializeWatcherFor: aObject.	watcher become: aObject.	meta := MetaWatcher for: aObject.	aObject classLookup: aClass.	aObject addBehavior.	aObject receiver: watcher.	aObject becomeHandle.	^ meta! !!Watcher class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07' prior: 33664957!InitializeWatcherFor: aObject 	^ aObject class! !((PackageInfo named: 'Handles') classes) do:[:each | each methodDict do: [:each2 | each compile: (each2 getSource)].	each class methodDict do: [:each3 | each class compile: (each3 getSource)].		]!"handles"!----QUIT/NOSAVE----an Array(2 December 2010 3:19:36 pm) Handle-Image.TEST.image priorSource: 117504!----STARTUP----an Array(2 December 2010 3:27:08 pm) as /Users/arnaudj/Desktop/GIT/Handle/Image/Handle-Image.TEST.image!!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:27' prior: 33659816!changeStaticHierarchy: aMethodDict to: aClass aMethodDict		do: [:each | each methodClass: aClass].	^ methodDict ! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:27' prior: 33661903!debugMirrorFor: aObject 	| aClass handle | 	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior.	^ handle! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:27' prior: 33661134!reflect: aObject	| aBehavior  aMethodDict |	aMethodDict  := aObject class methodDict copy.	aMethodDict		addAll: (self changeStaticHierarchy: self methodDict copy  to: aObject class).	aBehavior := Behavior new setFormat: aObject class format;				 superclass: aObject class superclass;				 methodDict: aMethodDict.	aBehavior superclass: aObject class.	^ aBehavior! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:27' prior: 33908440!reflect: aObject	| aBehavior  aMethodDict |	aMethodDict  := aObject class methodDict copy.	aMethodDict		addAll: (self changeStaticHierarchy: self methodDict copy to: aObject class).	aBehavior := Behavior new setFormat: aObject class format;				 superclass: aObject class superclass;				 methodDict: aMethodDict.	aBehavior superclass: aObject class.	^ aBehavior! !!AbstractMirrorHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:28' prior: 33661615!mirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior; becomeHandle. 	^ handle! !Handle subclass: #AbstractMirrorHandle2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-ApplicationMirrorAPI'!!AbstractMirrorHandle2 class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:28'!changeStaticHierarchy: aMethodDict to: aClass aMethodDict		do: [:each | each methodClass: aClass].	^ methodDict ! !!AbstractMirrorHandle2 class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:28'!debugMirrorFor: aObject 	| aClass handle | 	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior.	^ handle! !!AbstractMirrorHandle2 class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:28'!mirrorFor: aObject 	| aClass handle |	aClass := self reflect: aObject.	handle := self debugFor: aObject to: aClass.	handle removeState; addBehavior; becomeHandle. 	^ handle! !!AbstractMirrorHandle2 class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:28'!reflect: aObject	| aBehavior  aMethodDict |	aMethodDict  := aObject class methodDict copy.	aMethodDict		addAll: (self changeStaticHierarchy: self methodDict copy to: aObject class).	aBehavior := Behavior new setFormat: aObject class format;				 superclass: aObject class superclass;				 methodDict: aMethodDict.	aBehavior superclass: aObject class.	^ aBehavior! !----QUIT----an Array(2 December 2010 3:31:38 pm) Handle-Image.TEST.image priorSource: 117504!
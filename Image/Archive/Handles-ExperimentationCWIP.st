Handle subclass: #CapabilityHandle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-ExperimentationCWIP'!!CapabilityHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!copy: t1 withCapabilities: t2 	| t3 |	t3 := MethodDictionary new.	t2		do: [:t4 | t3 at: t4 put: (t1 class methodDict at: t4) copy].	^ Behavior new setFormat: t1 class format;		 superclass: t1 class superclass;		 methodDict: t3! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CapabilityHandle class	instanceVariableNames: ''!!CapabilityHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!debugFor: t1 to: t2 	self shouldNotImplement! !!CapabilityHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!debugFor: t1 with: t2 	| t3 t4 |	t4 := self createHandle.	t3 := t4 copy: t1 withCapabilities: t2.	t4 initializeHandleWith: t1 to: t3.	t4 addBehavior; removeState.	^ t4! !!CapabilityHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!for: t1 with: t2 	| t3 |	t1 isLiteral		ifTrue: [^ t1].	t3 := self debugFor: t1 with: t2.	[t3 becomeHandle]		on: Exception		do: [].	^ t3! !Handle subclass: #ClassHandle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-ExperimentationCWIP'!!ClassHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!initialize	super initialize.	self removeBehavior.	self addState! !!ClassHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!initializeHandleWith: t1 to: t2 	| t3 t4 |	receiver := t1.	classLookup := t2.	t3 := t1 class allInstVarNames size.	state := Array new: t3.	state at: 1 put: (t1 instVarAt: 1) copy.	t4 := (t1 instVarAt: 2) copy.	t4 := t4				collect: [:t6 | t6 copy].	state at: 2 put: t4.	3		to: t3		do: [:t5 | state at: t5 put: (t1 instVarAt: t5) copy]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassHandle class	instanceVariableNames: ''!!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!addInstVarName	^ 'addInstVarName: aString					'! !!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!for: t1 	| t2 |	t1 isLiteral		ifTrue: [^ t1].	t2 := self debugFor: t1 to: StructuralHandleClass.	t2 addBehavior; addState.	t2 becomeHandle.	^ t2! !!ClassHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!recreateClassHandle: t1 with: t2 	| t3 |	t3 := self debugFor: t1 to: nil.	t3 removeBehavior; addState.	t3 addInstanceVar: t2.	t3 becomeHandle.	t3 compile: self methodClass.	^ t3! !Class subclass: #ClassJB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-ExperimentationCWIP'!!ClassJB methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!addClassVarName: t1 	Transcript show: 'Handle Rule';		 cr.	^ super addClassVarName: t1! !Handle subclass: #ObjectHandle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-ExperimentationCWIP'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ObjectHandle class	instanceVariableNames: ''!!ObjectHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!debugFor: t1 to: t2 	| t3 t4 t5 |	t3 := self createHandle.	t4 := ClassHandle for: t2.	t3 initializeHandleWith: t1 to: t4.	^ t3! !Handle subclass: #RewriteMethodHandle	instanceVariableNames: ''	classVariableNames: 'Store'	poolDictionaries: ''	category: 'Handles-ExperimentationCWIP'!!RewriteMethodHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!rewrite: t1 withRule: t2 	self		storeAt: t1 class		ifAbsent: [| t3 t5 |			t3 := OrderedCollection new.			t1 class				allSuperclassesDo: [:t6 | t3 add: t6].			t3 addFirst: t1 class.			t3 := t3 reverse.			t5 := UndefinedObject.			t3				do: [:t6 | t5 := self								storeAt: t6								ifAbsent: [| t7 |									t7 := Behavior new setFormat: t6 format;												 superclass: t5;												 methodDict: MethodDictionary new.									self										rewriteDictionaryOf: t6										putIn: t7										with: t2.									self storeAt: t6 put: t7.									t7]]].	^ self storeAt: t1 class! !!RewriteMethodHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!rewriteDictionaryOf: t1 putIn: t2 with: t3 	t1 methodDict		do: [:t4 | t2				compile: (t3 value: t4)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RewriteMethodHandle class	instanceVariableNames: ''!!RewriteMethodHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!debugFor: t1 rule: t2 	| t3 t4 |	t3 := self createHandle.	t4 := t3 rewrite: t1 withRule: t2.	t3 initializeHandleWith: t1 to: t4.	^ t3! !!RewriteMethodHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!debugFor: t1 to: t2 	self error: 'This class doesnt work with this interface use #debugFor:rule selector'! !!RewriteMethodHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!for: t1 rule: t2 	| t3 |	t1 isLiteral		ifTrue: [^ t1].	t3 := self debugFor: t1 rule: t2.	[t3 becomeHandle]		on: Exception		do: [].	^ t3! !RewriteMethodHandle subclass: #RewriteMethodWithPropagationHandle	instanceVariableNames: 'rule'	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-ExperimentationCWIP'!!RewriteMethodWithPropagationHandle methodsFor: 'Private' stamp: 'JB 12/2/2010 15:07'!propagate: t1 through: t2 	| t3 t4 t5 t6 |	t3 := RBParseTreeRewriter new.	t3 replace: self matchingMessageSuperSendRule with: self rewritingMessageSuperSendRule.	t3 replace: self matchingMessageSelfRule with: self rewritingMessageSelfRule.	t2		do: [:t7 | t3 replace: t7 , '`@message: `@args' with: '(' , self class printString , ' for: ' , t7 , ' rule: ' , self rule printString , ') `@message: `@args'].	t4 := t3				executeTree: (RBParser parseMethod: t1);				 tree.	^ t4 formattedCode! !!RewriteMethodWithPropagationHandle methodsFor: 'propagation rule ' stamp: 'JB 12/2/2010 15:07'!matchingMessageSelfRule	^ ' self `@message: `@args'! !!RewriteMethodWithPropagationHandle methodsFor: 'propagation rule ' stamp: 'JB 12/2/2010 15:07'!matchingMessageSuperSendRule	^ ' super `@message: `@args'! !!RewriteMethodWithPropagationHandle methodsFor: 'propagation rule ' stamp: 'JB 12/2/2010 15:07'!rewritingMessageSelfRule	^ '(' , self class printString , ' for: self rule: ' , self rule printString , ' ) `@message: `@args'! !!RewriteMethodWithPropagationHandle methodsFor: 'propagation rule ' stamp: 'JB 12/2/2010 15:07'!rewritingMessageSuperSendRule	^ '(' , self class printString , ' superFor: self rule: ' , self rule printString , ' ) `@message: `@args'! !!RewriteMethodWithPropagationHandle methodsFor: 'rule management' stamp: 'JB 12/2/2010 15:07'!rule	^ state! !!RewriteMethodWithPropagationHandle methodsFor: 'rule management' stamp: 'JB 12/2/2010 15:07'!rule: t1 	state := t1! !!RewriteMethodWithPropagationHandle methodsFor: 'interface' stamp: 'JB 12/2/2010 15:07'!rewriteDictionaryOf: t1 putIn: t2 with: t3 	| t4 |	t1 methodDict		do: [:t5 | 			| t6 |			t6 := t5 getSource.			t6 := self propagate: t6 through: t1 instVarNames.			[t2 compile: t6]				on: Error				do: [Transcript show: t5 selector;						 cr]]! !!RewriteMethodWithPropagationHandle methodsFor: 'initialize-release' stamp: 'JB 12/2/2010 15:07'!initialize	^ super initialize! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RewriteMethodWithPropagationHandle class	instanceVariableNames: ''!!RewriteMethodWithPropagationHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!debugFor: t1 rule: t2 	| t3 t4 |	t3 := self createHandle.	t3 rule: t2.	t4 := t3 rewrite: t1 withRule: t2.	t3 initializeHandleWith: t1 to: t4.	^ t3! !Class subclass: #StructuralHandleClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-ExperimentationCWIP'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StructuralHandleClass class	instanceVariableNames: ''!!StructuralHandleClass class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!addInstVarName: t1 	<primitive: 577>	self primitiveFailed! !!StructuralHandleClass class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!class	<primitive: 576>	self primitiveFailed! !
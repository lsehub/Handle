Object subclass: #Handle	instanceVariableNames: 'receiver classLookup state configuration'	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Core'!!Handle methodsFor: 'accessing' stamp: 'JB 12/2/2010 15:07'!classLookup	^ classLookup! !!Handle methodsFor: 'accessing' stamp: 'JB 12/2/2010 15:07'!classLookup: aClass 	classLookup := aClass! !!Handle methodsFor: 'accessing' stamp: 'JB 12/2/2010 15:07'!configuration	^ configuration! !!Handle methodsFor: 'accessing' stamp: 'JB 12/2/2010 15:07'!receiver	^ receiver! !!Handle methodsFor: 'accessing' stamp: 'JB 12/2/2010 15:07'!receiver: aObject 	receiver := aObject! !!Handle methodsFor: 'activating' stamp: 'JB 12/2/2010 15:07'!becomeHandle	<primitive: 575>	^ self primitiveFailed! !!Handle methodsFor: 'testing' stamp: 'JB 12/2/2010 15:07'!isHandler	^ true! !!Handle methodsFor: 'initialize-release' stamp: 'JB 12/2/2010 15:07'!initialize	classLookup := nil.	configuration := 0.	self removeBehavior.	self removeState! !!Handle methodsFor: 'initialize-release' stamp: 'JB 12/2/2010 15:07'!initializeHandleWith: aObject to: aClass 	| size |	receiver := aObject.	classLookup := aClass.	size := aObject class allInstVarNames size.	state := Array new: size.	1		to: size		do: [:index | state				at: index				put: (aObject instVarAt: index)]! !!Handle methodsFor: 'option' stamp: 'JB 12/2/2010 15:07'!addBehavior	self classLookup		ifNil: [^ Error signal: 'classLookup  isNil you want to crash the VM ?'].	configuration := configuration bitOr: 2! !!Handle methodsFor: 'option' stamp: 'JB 12/2/2010 15:07'!addSelfWrapping	configuration := configuration bitOr: 4! !!Handle methodsFor: 'option' stamp: 'JB 12/2/2010 15:07'!addState	configuration := configuration bitOr: 1! !!Handle methodsFor: 'option' stamp: 'JB 12/2/2010 15:07'!removeBehavior	configuration := configuration bitAnd: 5! !!Handle methodsFor: 'option' stamp: 'JB 12/2/2010 15:07'!removeSelfWrapping	configuration := configuration bitAnd: 3! !!Handle methodsFor: 'option' stamp: 'JB 12/2/2010 15:07'!removeState	configuration := configuration bitAnd: 6! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Handle class	instanceVariableNames: ''!!Handle class methodsFor: 'newStuff' stamp: 'JB 12/2/2010 15:07'!debugFor: aObject	| handle |	handle := self createHandle.	handle receiver: aObject.	handle addState.	^ handle! !!Handle class methodsFor: 'newStuff' stamp: 'JB 12/2/2010 15:07'!debugFor: aObject to: aClass 	| handle |	handle := self createHandle.	handle initializeHandleWith: aObject to: aClass.	^ handle! !!Handle class methodsFor: 'newStuff' stamp: 'JB 12/2/2010 15:07'!for: aObject 	| handle |	handle := self debugFor: aObject to: nil.	handle removeBehavior; addState.	handle becomeHandle.	^ handle! !!Handle class methodsFor: 'newStuff' stamp: 'JB 12/2/2010 15:07'!for: aObject to: aClass 	| handle |	handle := self debugFor: aObject to: aClass.	handle addBehavior.	handle becomeHandle.	^ handle! !!Handle class methodsFor: 'instance creation' stamp: 'JB 12/2/2010 15:07'!createHandle	^ self new! !Handle subclass: #MetaHandle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Core'!!MetaHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!initialize	super initialize! !!MetaHandle methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!isMeta	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MetaHandle class	instanceVariableNames: ''!!MetaHandle class methodsFor: 'accessing' stamp: 'JB 12/2/2010 15:07'!for: aHandle	^ self for: aHandle  to: self! !
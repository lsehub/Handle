AbstractTutorial subclass: #HowDoUseHandle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Documentations'!!HowDoUseHandle methodsFor: 'tutorial' stamp: 'JB 12/2/2010 15:07'!tutorial	^ #(#handlePreTest handlePrinciple handleFirstStep handleSecondStep handleThirdStep handleFourStep handleMeta)! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 12/2/2010 15:07'!handleFirstStep	^ Lesson title: 'handle first indirection' lesson: '"The API for using handle is very simple."|a handleOfA |"If you want to create a Handle"a := A new. "create a instance of A"handleOfA := Handle for: a to: B. "We create a handle on ''a'' and redirect the behavior to B""That mean all the message send to a will be execute with method dictionnary of A"a isA.a isB."That mean all the message send to handleOfA will be execute with method dictionnary of B"handleOfA isA.handleOfA isB.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 12/2/2010 15:07'!handleFourStep	^ Lesson title: 'handle ' lesson: '"Advance use of Handle. Need to have fine grain configuration :"	"All access API	Basic accessHandle for: (Object new).  => create a Handle that do indirection on state of the object.Handle for: (Object new) to: Class. => create a handle that do indirection on behavior of the object redirect to the class.""Fine Grain configuration"Handle debugFor: (Object new). " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the state indirection."Handle debugFor: (Object new) to: Class. " => create a non activate handle, which your are able to configure using the configuration interface. but initialize the value of the behavior indirection.""accessorreceiver & receiver: is the target object behind the handle. Should be initialize.classLookup & classLookup: : is a accessor to where the lookup should begin. Should be initialize if you would like to have behavior indirection.Configuration interfaceaddBehavior & removeBehavior => enable/disable the behavior indirection.addState & removeState => enable/disable the state indirection.addSelfWrapping & addSelfWrapping => enable/disable the behavior such self representing the receiver or a handle on receiver, it is wrap then self represent a handle on receiver.Activate Handleis do by sending the message becomeHandle to a unactivate handle."(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	becomeHandle."create a handle doing indirection on behavior and state"(Handle debugFor: (Object new))	classLookup: Object;	addBehavior;	removeState;	becomeHandle.	"do the same thing than"Handle for: (Object new) to: Object.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 12/2/2010 15:07'!handleMeta	^ Lesson title: 'Smell like meta ? ' lesson: '"At origine the Handle was design for control execution flow, but once activate you don''t have any control on it that why we can create a MetaHandle"	"A MetaHandle is a Handle defining the behavior on a Handle, is a direct subclass of handle.""Create a MetaHandle One security restriction, you should create the MetaHandle before activating the handle. For a simple question of security you should not escape from handle"|metaH handle |handle := Handle debugFor: (A new) to: B.metaH := MetaHandle for: handle.handle becomeHandle."Then now you can do funny thing like changing indirection during execution just by sending a message to MetaHandle"handle isB. metaH classLookup: A.handle isA.handle var1. "''var1''"metaH addState.handle var1: ''state save''.handle var1.  "''state save''"metaH removeStatehandle var1."  ''var1''"metaH addState.handle var1.  "''state save''""Be care to not lost the Reference MetaHandle or you can not changing the handle anymore !!!!""It''s enough for the core of Handle"ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 12/2/2010 15:07'!handlePreTest	^ Lesson title: 'handle support?' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachineForHandle." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zipAndTestYourImage :"HowDoUseHandle testImageForHandle."If this test fails, you can load the code by loading the configurationOfHandle"ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 12/2/2010 15:07'!handlePrinciple	^ Lesson title: 'handle principle' lesson: '"As we say previously Handle is a special object that allow you to create indirection on Behavior or on State.This tutorial, is separate in 3 Step,	- Learn the Core model of The Handle and How to use it.	- Learn how use the different application created for the handle.	- And learn how extend Handles to create your specifique indirection on Handle.the core Model of Handle is pretty simple, is just composed of 2 class,Handle : Handle is a object know by the VM, it''s represent a indirection, do on a object, such a transparent proxy.MetaHandle : MetaHandle is Handle which able to configure the Handle. We need this object because once we activate a handle, is become a unreachable object. Invisible From the image part."ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 12/2/2010 15:07'!handleSecondStep	^ Lesson title: 'handle ' lesson: '"The API for using handle is very simple.""a important point, the object access by the handle is not a copy of the object it''s the same object : ""concequently a object and this handle have the SAME identity because he represente just a another version of the same object.try "|a handleOfA |a := A new. "create a instance of A"handleOfA := Handle for: a to: AA. "We create a handle on ''a'' and redirect the behavior to AA a subclassOfA"a == handleOfA."In addition, if the someone change one of this reference that will change the other reference"a := A new.handleOfA := Handle for: a to: AA. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 12/2/2010 15:07'!handleThirdStep	^ Lesson title: 'handle ' lesson: '"The other skill of the handle is to create indirection on StateThat mean you can create a Handle, which keep this own state.try"|a handleOfA |a := A new.handleOfA := Handle for: a. a var1: ''test''.handleOfA var1 = ''test''.handleOfA var1: ''test2''.a var1 = ''test2''.ProfStef next.'! !!HowDoUseHandle methodsFor: 'lesson' stamp: 'JB 12/2/2010 15:07'!handleWhatIsIt	^ Lesson title: 'handle support?' lesson: '"A handle is a special object that allow you to do indirection behavior or on state.He need to use a special VM, and have to do some modification on your image.That why before begining we should check your VM :"HowDoUseHandle testVirtualMachine." If this test fails, you can find the virtual machine needed to use handle at this adress:http://dl.dropbox.com/u/7879914/HandleLast.zip" AndTestYourImage :"HowDoUseHandle testImage."If this test fails, you can load the code by loading the configurationOfHandle""ProfStef next.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HowDoUseHandle class	instanceVariableNames: ''!!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testImageForHandle	^[(SmalltalkImage current specialObjectsArray at: 51) == Handle] on: Error do:[false]! !!HowDoUseHandle class methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testVirtualMachineForHandle	[(Handle new) becomeHandle] on: Error do: [^false].	^true.! !
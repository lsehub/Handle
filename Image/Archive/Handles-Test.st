TestCase subclass: #ClassHandleTest	instanceVariableNames: 'className renamedName'	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!ClassHandleTest methodsFor: 'setup' stamp: 'JB 12/2/2010 15:07'!deleteClass	| mustRemove |	mustRemove := Smalltalk globals				at: className				ifAbsent: [^ self].	mustRemove removeFromChanges; removeFromSystemUnlogged! !!ClassHandleTest methodsFor: 'setup' stamp: 'JB 12/2/2010 15:07'!deleteRenamedClass	| mustRemove |	mustRemove := Smalltalk globals				at: renamedName				ifAbsent: [^ self].	mustRemove removeFromChanges; removeFromSystemUnlogged! !!ClassHandleTest methodsFor: 'setup' stamp: 'JB 12/2/2010 15:07'!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassHandleTest methodsFor: 'testing' stamp: 'JB 12/2/2010 15:07'!testAddInstVarName	| classHandle |	classHandle := ClassHandle for: A.	classHandle addInstVarName: 'x'.	self assert: classHandle instVarNames = #('x' ).	classHandle addInstVarName: 'y'.	self assert: classHandle instVarNames = #('x' 'y' )! !!ClassHandleTest methodsFor: 'testing' stamp: 'JB 12/2/2010 15:07'!testRenaming	^ self! !!ClassHandleTest methodsFor: 'testing - class variables' stamp: 'JB 12/2/2010 15:07'!testClassVarNames	self		assert: ((ClassHandle for: A) classVarNames includes: #Coucou).	self assert: (ClassHandle for: A) classVarNames = (ClassHandle for: A) class classVarNames! !!ClassHandleTest methodsFor: 'testing - compiling' stamp: 'JB 12/2/2010 15:07'!testCompileAll	self		shouldnt: [(ClassHandle for: A) compileAll]		raise: Error! !!ClassHandleTest methodsFor: 'functional test' stamp: 'JB 12/2/2010 15:07'!expectedFailures	^#(#testCreationMethodOnHandle).! !!ClassHandleTest methodsFor: 'functional test' stamp: 'JB 12/2/2010 15:07'!testCreationMethodOnHandle	"| t1 t2 t3 t4 |	t3 := PropagationTestClass new.	t1 := RewriteMethodWithPropagationHandle				debugFor: t3				rule: [].	t4 := t1 classLookup.	t1 becomeHandle.	t4 compile: 'testToRemove ^false'.	self		shouldnt: [t1 testToRemove]		raise: MessageNotUnderstood.	self		should: [t3 testToRemove]		raise: MessageNotUnderstood"! !TestCase subclass: #HandleBehaviorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!HandleBehaviorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testInterceptMessage	| handle |	handle := Handle debugFor: A new to: B.	handle addBehavior; removeState; becomeHandle.	self assert: handle testReturn = 'success'! !!HandleBehaviorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testdontChangeOriginalObject	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeState; becomeHandle.	self assert: trueObject isA.	self deny: trueObject isB.	self assert: handle isB.	self deny: handle isA! !TestCase subclass: #HandleCapabilitiesTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testCapabilitiesPrivateAccess	self		should: [(CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublicInterface )) thisIsPrivateMethod]		raise: MessageNotUnderstood! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testCapabilitiesPrivateThroughtPublicAccess	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublicInterface )) thisIsPublicInterface]		raise: MessageNotUnderstood.	self assert: (CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublicInterface )) thisIsPublicInterface = 'You access to a private zone'! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testCapabilitiesPublicAccess	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublic )) thisIsPublic]		raise: MessageNotUnderstood.	self assert: (CapabilityHandle for: CapabilityTestClass new with: #(#thisIsPublic )) thisIsPublic = 'It is public'! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testCapabilitiesSelfTest	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#takeCareAboutSelf )) takeCareAboutSelf]		raise: MessageNotUnderstood.	self		should: [(CapabilityHandle for: CapabilityTestClass new with: #(#takeCareAboutSelf )) takeCareAboutSelf thisIsPrivateMethod]		raise: MessageNotUnderstood! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testCapabilitiesStoreAndReturnSelf	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#storeAndReturnSelf )) storeAndReturnSelf]		raise: MessageNotUnderstood.	self		should: [(CapabilityHandle for: CapabilityTestClass new with: #(#storeAndReturnSelf )) storeAndReturnSelf thisIsPrivateMethod]		raise: MessageNotUnderstood! !!HandleCapabilitiesTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testCapabilitiesStoreAndReturnSelfInstance	self		shouldnt: [(CapabilityHandle for: CapabilityTestClass new with: #(#storeAndReturnSelf2 )) storeAndReturnSelf2]		raise: MessageNotUnderstood.	self		should: [(CapabilityHandle for: CapabilityTestClass new with: #(#storeAndReturnSelf2 )) storeAndReturnSelf2 thisIsPrivateMethod]		raise: MessageNotUnderstood! !TestCase subclass: #HandleIdentityTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testIdentityObject1	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testIdentityObject2	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testIdentityObject3	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; addState; becomeHandle.	self assert: trueObject == handle! !!HandleIdentityTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testIdentityObject4	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; removeState; becomeHandle.	self assert: trueObject == handle! !TestCase subclass: #HandleOtherTest	instanceVariableNames: 'storeIntoInstVar'	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testRemoveTwice	| handle trueObject |	trueObject := AA new.	handle := (Handle debugFor: trueObject to: A) addBehavior; addState.	handle removeState.	handle removeState.	self assert: handle configuration = 2.	handle removeBehavior.	handle removeBehavior.	self assert: handle configuration = 0! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testStoreIntoInstVarReference	storeIntoInstVar := (Handle debugFor: A new to: B) becomeHandle.	self assert: storeIntoInstVar isA.	self deny: storeIntoInstVar isB! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testStoreIntoTempReference	| handle |	handle := (Handle debugFor: A new to: B) addBehavior; removeState; becomeHandle.	self assert: handle isB.	self deny: handle isA! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testStoreIntoTempReference2	| handle |	handle := (Handle debugFor: A new to: B) addBehavior; addState; becomeHandle.	self assert: handle isB.	self deny: handle isA! !!HandleOtherTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testUseStateThenStopToUseIt	| handle meta trueObject |	trueObject := AA new.	handle := (Handle debugFor: trueObject to: A) addBehavior; addState.	meta := MetaHandle for: handle.	handle becomeHandle.	handle var1: 'testHandle'.	self assert: handle var1 = 'testHandle'.	meta removeState.	self deny: handle var1 = 'testHandle'.	self assert: trueObject var1 = handle var1.	meta addState.	self assert: handle var1 = 'testHandle'! !TestCase subclass: #HandleSelfWrappingTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!HandleSelfWrappingTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testActiveSelfWrap	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; addSelfWrapping; becomeHandle.	self		shouldnt: [handle activeTestWrap]		raise: MessageNotUnderstood! !!HandleSelfWrappingTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testDesactiveSelfWrap	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle addBehavior; removeSelfWrapping; becomeHandle.	self		should: [handle activeTestWrap]		raise: MessageNotUnderstood! !TestCase subclass: #HandleStateTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!HandleStateTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testChangingStateOrigine	| trueObject handle |	trueObject := A new.	handle := Handle debugFor: trueObject to: B.	handle removeBehavior; addState; becomeHandle.	trueObject var1: 'test'.	self deny: handle var1 = 'test'! !TestCase subclass: #MirrorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testLookupReadSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) lookupReadSend = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testMirrorOverLookSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorOverLookSend = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testMirrorOverSuperSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorOverSuperSend = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testMirrorSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) mirrorSend = 'mirror'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testOverload	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) toOverLoad = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testReadAccess	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) readAccess = 'success'! !!MirrorTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testSuperReadSend	self assert: (MirrorHandleTest mirrorFor: MirrorHandleSubClassTest new) superReadSend = 'success'! !TestCase subclass: #PrimitivesScopeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!PrimitivesScopeTest methodsFor: 'as yet unclassified' stamp: 'JB 12/2/2010 15:07'!testBeeper	self		should: [MyBeeper primitiveBeep]		raise: MessageNotUnderstood.	self		shouldnt: [(PrimitivesScope mirrorFor: MyBeeper) primitiveBeep]		raise: MessageNotUnderstood! !TestCase subclass: #PropagationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Handles-Test'!!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 12/2/2010 15:07'!testInstVar"	| t1 t2 |	t2 := #instanceVar.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 12/2/2010 15:07'!testSelf"	| t1 t2 |	t2 := #self.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 12/2/2010 15:07'!testSendToInstVar"	| t1 t2 |	t2 := #sendToInstanceVar.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 12/2/2010 15:07'!testSendToSelf"	| t1 t2 |	t2 := #sendToSelf.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 12/2/2010 15:07'!testSendToSuper"	| t1 t2 |	t2 := #sendToSuper.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 12/2/2010 15:07'!testSendToTemp"	| t1 t2 |	t2 := #sendToTemp.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'BasicTest' stamp: 'JB 12/2/2010 15:07'!testTemp"	| t1 t2 |	t2 := #temp.	t1 := RewriteMethodWithPropagationHandle				debugFor: PropagationTestClass new				rule: [].	self deny: (t1 classLookup methodDict at: t2) getSource = (PropagationTestClass methodDict at: t2) getSource.	self assert: (t1 classLookup methodDict at: t2) getSource			= (PropagationTestClass perform: t2)"! !!PropagationTest methodsFor: 'functional test' stamp: 'JB 12/2/2010 15:07'!testCreationMethodOnOriginate	"| t1 t2 t3 |	t3 := PropagationTestClass new.	t1 := RewriteMethodWithPropagationHandle				for: t3				rule: [].	PropagationTestClass compile: 'testToRemove ^false'.	self		should: [t1 testToRemove]		raise: MessageNotUnderstood.	self		shouldnt: [t3 testToRemove]		raise: MessageNotUnderstood"! !!PropagationTest methodsFor: 'private' stamp: 'JB 12/2/2010 15:07'!setUp	RewriteMethodWithPropagationHandle resetAll! !!PropagationTest methodsFor: 'private' stamp: 'JB 12/2/2010 15:07'!tearDown	PropagationTestClass removeSelector: #testToRemove! !